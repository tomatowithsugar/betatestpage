<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>불광서부회중 전시대 신청</title>
    <link rel="apple-touch-icon" href="apple-touch-icon_v3.png">
    <link rel="icon" type="image/png" href="favicon-512x512_v3.png">

    <!-- Firebase SDK -->
    <script type="module">
        import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js';
        import { getFirestore, collection, addDoc, getDocs, query, where, onSnapshot, deleteDoc, doc, setDoc, updateDoc, arrayUnion, arrayRemove, getDoc } from 'https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js';

        // Firebase 설정
        const firebaseConfig = {
apiKey: "AIzaSyCUe4dXiwGiMsKtMCQfLVScx9iM4sEwF50",
authDomain: "cart-witnessing-404c0.firebaseapp.com",
projectId: "cart-witnessing-404c0",
storageBucket: "cart-witnessing-404c0.firebasestorage.app",
messagingSenderId: "616001042576",
appId: "1:616001042576:web:314fe2268c8fffe82a8015",
measurementId: "G-HT3T8YS1MW"
        };

        const messengerFirebaseConfig = {
            apiKey: "AIzaSyAGTCpQGZw28QkEpaBy-62pi0PhgOMt_i0",
            authDomain: "bgs-messeger.firebaseapp.com",
            projectId: "bgs-messeger",
            storageBucket: "bgs-messeger.firebasestorage.app",
            messagingSenderId: "823756736946",
            appId: "1:823756736946:web:5a35d2e0604972a6d43cab",
            measurementId: "G-JB4LFXKWDX"
        };

        // Firebase 초기화
        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);

        // 전역에서 사용할 수 있도록 window 객체에 저장
        window.firebaseApp = app;
        window.db = db;
        window.firestoreFunctions = {
            collection, addDoc, getDocs, query, where, onSnapshot, deleteDoc, doc, setDoc, updateDoc, arrayUnion, arrayRemove, getDoc
        };
        window.messengerFirebaseConfig = messengerFirebaseConfig; // 메신저 설정도 전역에 추가

        // DOM이 로드된 후 실행
        window.addEventListener('DOMContentLoaded', function () {
            window.initializeApp();
        });
    </script>

        <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>

    <style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}
:root {
  --base-font-size: 16px;
  --heading-font-size: 26px;
  --button-font-size: 17px;
  --label-font-size: 15px;
  --small-font-size: 13px;
}

body {
    font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', 'Segoe UI', Roboto, sans-serif;
    background: linear-gradient(145deg, #667eea 0%, #764ba2 50%, #667eea 100%);
    background-size: 400% 400%;
    animation: gradientShift 15s ease infinite;
    min-height: 100vh;
    display: flex;
    justify-content: center;
    align-items: flex-start;
    padding: 0;
    color: #1a202c;
}

@keyframes gradientShift {
    0% { background-position: 0% 50%; }
    50% { background-position: 100% 50%; }
    100% { background-position: 0% 50%; }
}


.container {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(20px);
    -webkit-backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.2);
    padding: 0;
    border-radius: 0;
    box-shadow: none;
    width: 100%;
    max-width: 100%;
    min-height: 100vh;
    position: relative;
    overflow: hidden;
    display: flex;
    flex-direction: column;
}

h1 {
    text-align: center;
    color: #1a202c;
    margin: 0;
    padding: 40px 20px 30px;
    font-size: 26px;
    font-weight: 800;
    line-height: 1.3;
    position: relative;
    z-index: 2;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.login-page, .main-page, .admin-page {
    padding: 20px;
    position: relative;
    z-index: 2;
    margin-top: 20px;
    flex-shrink: 0;
}

.login-page {
    display: block;
}

.main-page, .admin-page {
    display: none;
}

.form-group {
    margin-bottom: 24px;
}

label {
    display: block;
    margin-bottom: 10px;
    color: #2d3748;
    font-weight: 600;
    font-size: var(--label-font-size);
    text-align: left;
}

input[type="text"], select, textarea, input[type="number"] {
    width: 100%;
    padding: 18px 20px;
    border: none;
    border-radius: 16px;
    font-size: var(--base-font-size);
    background: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(102, 126, 234, 0.2);
    transition: all 0.3s ease;
    box-shadow: 0 4px 20px rgba(0,0,0,0.05);
}

input[type="text"]:focus, select:focus, textarea:focus, input[type="number"]:focus {
    outline: none;
    background: white;
    border-color: #667eea;
    box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1), 0 8px 30px rgba(0,0,0,0.1);
    transform: translateY(-2px);
}

.btn {
    width: 100%;
    padding: 20px;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    border-radius: 16px;
    font-size: var(--button-font-size);
    font-weight: 700;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    margin-bottom: 14px;
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
    position: relative;
    overflow: hidden;
}

.btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    transition: left 0.6s;
}

.btn:hover::before {
    left: 100%;
}

.btn:active {
    transform: scale(0.98);
}

.btn.secondary {
    background: linear-gradient(135deg, #a0aec0 0%, #718096 100%);
    box-shadow: 0 8px 25px rgba(160, 174, 192, 0.3);
}

.btn.danger {
    background: linear-gradient(135deg, #fc8181 0%, #e53e3e 100%);
    padding: 14px 20px;
    width: auto;
    font-size: 14px;
    margin: 0;
    box-shadow: 0 6px 20px rgba(252, 129, 129, 0.3);
    border-radius: 12px;
}

.btn.success {
    background: linear-gradient(135deg, #68d391 0%, #38a169 100%);
    padding: 16px 24px;
    width: auto;
    font-size: 15px;
    margin: 0 5px;
    box-shadow: 0 6px 20px rgba(104, 211, 145, 0.3);
    border-radius: 12px;
}

.btn.admin {
    background: linear-gradient(135deg, #f6ad55 0%, #ed8936 100%);
    box-shadow: 0 8px 25px rgba(246, 173, 85, 0.3);
}

.btn.small {
    padding: 16px 22px;
    font-size: var(--label-font-size);
    width: auto;
}

.btn:disabled {
    background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e0 100%);
    cursor: not-allowed;
    transform: none;
    box-shadow: none;
}

.user-info, .admin-info {
    text-align: center;
    margin: 20px 0 32px;
    font-size: 18px;
    font-weight: 600;
    padding: 20px;
    border-radius: 16px;
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    position: relative;
    overflow: hidden;
}

.user-info {
    background: linear-gradient(135deg, rgba(102, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
    color: #667eea;
}

.admin-info {
    background: linear-gradient(135deg, rgba(246, 173, 85, 0.1) 0%, rgba(237, 137, 54, 0.1) 100%);
    color: #ed8936;
}

.action-buttons {
    display: flex;
    flex-direction: column;
    gap: 14px;
    margin-bottom: 32px;
}

.admin-actions {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 14px;
    margin-bottom: 32px;
}

.day-selection {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 12px;
    margin-top: 16px;
}

.zone-selection {
    display: grid;
    grid-template-columns: 1fr;
    gap: 12px;
    margin-top: 16px;
}

.day-option, .zone-option {
    position: relative;
}

.day-option input[type="radio"], .zone-option input[type="radio"] {
    display: none;
}

.day-label, .zone-label {
    display: block;
    padding: 20px 16px;
    border: none;
    border-radius: 16px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(102, 126, 234, 0.1);
    font-weight: 600;
    font-size: var(--label-font-size);
    position: relative;
    overflow: hidden;
}

.zone-label {
    padding: 24px 20px;
    font-size: var(--base-font-size);
}

.day-label::before, .zone-label::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: -1;
}

.day-option input[type="radio"]:checked + .day-label,
.zone-option input[type="radio"]:checked + .zone-label {
    color: white;
    border-color: #667eea;
    box-shadow: 0 8px 30px rgba(102, 126, 234, 0.4);
    transform: translateY(-2px);
}

.day-option input[type="radio"]:checked + .day-label::before,
.zone-option input[type="radio"]:checked + .zone-label::before {
    opacity: 1;
}

.day-label:active, .zone-label:active {
    transform: scale(0.98);
}

.date-info {
    font-size: var(--small-font-size);
    margin-top: 6px;
    color: #718096;
    font-weight: 500;
}

.day-option input[type="radio"]:checked + .day-label .date-info {
    color: rgba(255, 255, 255, 0.9);
}

.capacity-info {
    font-size: var(--small-font-size);
    margin-top: 8px;
    text-align: center;
    color: #718096;
    font-weight: 600;
    padding: 4px 8px;
    background: rgba(255, 255, 255, 0.5);
    border-radius: 8px;
    display: inline-block;
}

.zone-label .capacity-info {
    font-size: var(--label-font-size);
}

.applicants-list {
    margin-top: 32px;
    padding: 0;
    background: none;
    border-radius: 0;
    flex-grow: 1;
    overflow-y: auto;
    max-height: calc(100vh - 300px);
}

.applicants-list h3 {
    margin-bottom: 20px;
    color: #1a202c;
    font-size: 20px;
    font-weight: 800;
    text-align: center;
    padding: 0 20px;
}

.day-section {
    margin-bottom: 16px;
    padding: 0;
    background: none;
    border-radius: 0;
}

.day-title {
    font-weight: 800;
    color: #667eea;
    margin-bottom: 12px;
    font-size: var(--button-font-size);
    padding: 0 20px;
    background: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    padding: 16px 20px;
    margin: 0 20px 12px;
    border: 1px solid rgba(102, 126, 234, 0.1);
}

.zone-applicants {
    margin: 0 20px 10px;
    padding: 18px;
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(15px);
    border-radius: 12px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    box-shadow: 0 4px 20px rgba(0,0,0,0.08);
}

.zone-name {
    font-weight: 700;
    color: #2d3748;
    margin-bottom: 10px;
    font-size: var(--label-font-size);
}

.name-tag {
    display: inline-block;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 8px 14px;
    margin: 4px 6px 4px 0;
    border-radius: 20px;
    font-size: var(--small-font-size);
    font-weight: 600;
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.25);
    position: relative;
    overflow: hidden;
}

.name-tag::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
    transition: left 0.6s;
}

.name-tag:hover::before {
    left: 100%;
}

.applicant-names {
    line-height: 1.8;
    color: #4a5568;
    font-size: var(--label-font-size);
}

.zone-selection-container {
    display: none;
}

.zone-selection-container.show {
    display: block;
    animation: slideUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes slideUp {
    from { 
        opacity: 0; 
        transform: translateY(20px);
    }
    to { 
        opacity: 1; 
        transform: translateY(0);
    }
}

.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background: rgba(0,0,0,0.6);
    backdrop-filter: blur(8px);
    animation: modalFadeIn 0.3s ease;
}

@keyframes modalFadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

.modal-content {
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(20px);
    margin: 0;
    padding: 30px 20px;
    border-radius: 24px 24px 0 0;
    width: 100%;
    max-width: 100%;
    max-height: 90vh;
    overflow-y: auto;
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 -10px 40px rgba(0,0,0,0.15);
    animation: slideUpModal 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

@keyframes slideUpModal {
    from {
        transform: translateY(100%);
    }
    to {
        transform: translateY(0);
    }
}

.modal-content.large {
    max-width: 100%;
}

.close {
    position: absolute;
    right: 20px;
    top: 20px;
    color: #a0aec0;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease;
    background: rgba(255, 255, 255, 0.8);
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(10px);
}

.close:hover {
    color: #2d3748;
    background: white;
    transform: scale(1.1);
}

.modal h2 {
    text-align: center;
    color: #1a202c;
    margin-bottom: 32px;
    font-size: 24px;
    font-weight: 800;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.cancel-list {
    max-height: 400px;
    overflow-y: auto;
    padding-right: 5px;
}

.cancel-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 20px;
    margin-bottom: 12px;
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(10px);
    border-radius: 16px;
    border: 1px solid rgba(102, 126, 234, 0.1);
    box-shadow: 0 4px 20px rgba(0,0,0,0.05);
    transition: all 0.3s ease;
}

.cancel-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 8px 30px rgba(0,0,0,0.1);
}

.cancel-info {
    flex: 1;
}

.cancel-day {
    font-weight: 800;
    color: #667eea;
    font-size: var(--button-font-size);
}

.cancel-details {
    color: #718096;
    font-size: var(--small-font-size);
    margin-top: 4px;
    font-weight: 500;
}

.no-applications {
    text-align: center;
    color: #a0aec0;
    font-style: italic;
    padding: 60px 20px;
    font-size: var(--base-font-size);
    font-weight: 500;
}

.admin-form {
    margin-bottom: 24px;
}

.form-row {
    display: grid;
    grid-template-columns: 1fr;
    gap: 16px;
    margin-bottom: 20px;
}

.admin-action-buttons {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
}

/* stats-header 스타일 수정 */
.stats-header {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-bottom: 24px;
    flex-wrap: nowrap; /* 요소가 한 줄에 유지되도록 */
}

/* month-navigation 스타일 수정 */
.month-navigation {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 12px;
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(10px);
    padding: 10px 16px;
    border-radius: 12px;
    border: 1px solid rgba(102, 126, 234, 0.1);
    box-shadow: 0 4px 20px rgba(0,0,0,0.05);
    width: auto;
    max-width: 100%;
}

.month-nav-btn {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    border: none;
    border-radius: 10px;
    width: 40px; /* 버튼 크기 조정 */
    height: 40px;
    cursor: pointer;
    font-size: 14px; /* 폰트 크기 조정 */
    font-weight: bold;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
}

.month-nav-btn:hover {
    transform: scale(1.05);
    box-shadow: 0 6px 20px rgba(102, 126, 234, 0.4);
}

.current-month {
    font-size: 16px; /* 폰트 크기 조정 */
    font-weight: 700;
    color: #2d3748;
    width: auto; /* 고정 폭 제거 */
    text-align: center;
    white-space: nowrap; /* 텍스트 줄바꿈 방지 */
}

.stats-content {
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(15px);
    padding: 24px;
    border-radius: 16px;
    margin-bottom: 20px;
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 8px 30px rgba(0,0,0,0.08);
}

@media (max-width: 768px) {
    .stats-header {
        padding: 0 10px; /* 좌우 패딩 추가 */
    }

    .month-navigation {
        gap: 8px; /* 모바일에서 간격 축소 */
        padding: 8px 12px;
    }

    .month-nav-btn {
        width: 36px; /* 모바일에서 버튼 크기 축소 */
        height: 36px;
        font-size: 12px;
    }

    .current-month {
        font-size: 14px; /* 모바일에서 폰트 크기 축소 */
    }
}

@media (max-width: 390px) {
    .month-navigation {
        gap: 6px; /* 더 작은 화면에서 간격 축소 */
        padding: 6px 10px;
    }

    .month-nav-btn {
        width: 32px;
        height: 32px;
        font-size: 11px;
    }

    .current-month {
        font-size: 13px;
    }
}

.stats-summary {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    gap: 12px;
    margin-bottom: 24px;
}

.stat-card {
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(10px);
    padding: 20px;
    border-radius: 16px;
    text-align: center;
    box-shadow: 0 4px 20px rgba(0,0,0,0.05);
    border: 1px solid rgba(255, 255, 255, 0.3);
    transition: transform 0.3s ease;
}

.stat-card:hover {
    transform: translateY(-3px);
}

.stat-number {
    font-size: 28px;
    font-weight: 800;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 6px;
}

.stat-label {
    font-size: 13px;
    color: #718096;
    font-weight: 600;
}

.zone-stats {
    display: grid;
    grid-template-columns: 1fr;
    gap: 12px;
}

.zone-stat-card {
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(10px);
    padding: 18px;
    border-radius: 16px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.05);
    border: 1px solid rgba(255, 255, 255, 0.3);
    transition: transform 0.3s ease;
}

.zone-stat-card:hover {
    transform: translateY(-2px);
}

.zone-stat-title {
    font-weight: 700;
    color: #2d3748;
    margin-bottom: 12px;
    font-size: 16px;
}

.zone-stat-bar {
    background: rgba(226, 232, 240, 0.8);
    border-radius: 8px;
    height: 10px;
    margin-bottom: 8px;
    overflow: hidden;
    backdrop-filter: blur(5px);
}

.zone-stat-fill {
    background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
    border-radius: 8px;
    height: 100%;
    transition: width 0.6s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
}

.zone-stat-text {
    font-size: var(--label-font-size);
    color: #718096;
    font-weight: 600;
}

.user-list {
    margin-top: 28px;
    padding: 24px;
    background: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(15px);
    border-radius: 16px;
    max-height: 400px;
    overflow-y: auto;
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 8px 30px rgba(0,0,0,0.08);
}

.user-list h3 {
    margin-bottom: 18px;
    color: #1a202c;
    font-size: 18px;
    font-weight: 700;
}

.user-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 18px;
    margin-bottom: 10px;
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    border: 1px solid rgba(102, 126, 234, 0.1);
    transition: all 0.3s ease;
    box-shadow: 0 2px 8px rgba(0,0,0,0.04);
}

.user-item:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 20px rgba(0,0,0,0.1);
}

.user-name {
    font-weight: 600;
    color: #2d3748;
    font-size: 16px;
}

.version-info {
    text-align: center;
    font-size: 11px;
    color: rgba(255, 255, 255, 0.7);
    margin-top: 20px;
    font-weight: 500;
    padding: 0 20px;
}

.notice-button {
    position: fixed;
    top: 20px;
    right: 20px;
    width: 52px;
    height: 52px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    font-size: 20px;
    z-index: 999;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.3);
}

.notice-button.active {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
}

.notice-button.inactive {
    background: rgba(255, 255, 255, 0.9);
    color: #718096;
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
}

.notice-button:hover {
    transform: scale(1.1);
    box-shadow: 0 12px 35px rgba(102, 126, 234, 0.5);
}

.notice-badge {
    position: absolute;
    top: -2px;
    right: -2px;
    width: 14px;
    height: 14px;
    background: #e53e3e;
    border-radius: 50%;
    display: none;
    box-shadow: 0 2px 8px rgba(229, 62, 62, 0.4);
    animation: pulse 2s infinite;
}

@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); }
    100% { transform: scale(1); }
}

.notice-modal-content h2.important {
    color: #e53e3e;
}

.notice-modal-content h2.normal {
    color: #667eea;
}

.notice-date {
    font-size: 12px;
    color: #a0aec0;
    text-align: center;
    margin-top: 18px;
    font-weight: 500;
}

.important-notice-checkbox {
    margin-bottom: 20px;
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 16px;
    background: rgba(102, 126, 234, 0.05);
    border-radius: 12px;
    border: 1px solid rgba(102, 126, 234, 0.1);
}

.important-notice-checkbox input[type="checkbox"] {
    width: auto;
    margin: 0;
    transform: scale(1.3);
    accent-color: #667eea;
}

.important-notice-checkbox label {
    font-size: 15px;
    color: #2d3748;
    cursor: pointer;
    margin: 0;
    font-weight: 600;
}

::-webkit-scrollbar {
    width: 6px;
}

::-webkit-scrollbar-track {
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px;
}

::-webkit-scrollbar-thumb {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    border-radius: 10px;
}

::-webkit-scrollbar-thumb:hover {
    background: linear-gradient(135deg, #5a6fd8 0%, #6b46c1 100%);
}

@media (max-width: 768px) {
    body {
        padding: 0;
        align-items: flex-start;
    }
    
    .container {
        border-radius: 0;
        min-height: 100vh;
    }
    
    h1 {
        font-size: 24px;
        padding: 35px 20px 25px;
    }
    
    .admin-actions {
        grid-template-columns: 1fr;
        gap: 12px;
    }
    
    .day-selection {
        grid-template-columns: 1fr;
        gap: 10px;
    }
    
    .modal-content {
        padding: 25px 20px 35px;
        border-radius: 20px 20px 0 0;
        max-height: 85vh;
    }
    
    .stats-summary {
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
    }
    
    .cancel-item {
        flex-direction: column;
        align-items: stretch;
        gap: 16px;
    }
    
    .cancel-item .btn {
        width: 100%;
        margin: 0;
    }
    
    .notice-button {
        top: 16px;
        right: 16px;
        width: 48px;
        height: 48px;
        font-size: 18px;
    }
    
    .action-buttons .btn {
        padding: 22px;
        font-size: 18px;
        font-weight: 700;
    }
}

@supports (padding: max(0px)) {
    .container {
        padding-top: max(20px, env(safe-area-inset-top));
    }
    
    .notice-button {
        top: max(20px, calc(env(safe-area-inset-top) + 10px));
        right: max(20px, calc(env(safe-area-inset-right) + 10px));
    }
}

@media (prefers-reduced-motion: reduce) {
    * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
    }
    
    .btn::before {
        display: none;
    }
    
    .name-tag::before {
        display: none;
    }
}

@media (prefers-contrast: high) {
    .btn {
        border: 2px solid #2d3748;
    }
    
    .day-label, .zone-label {
        border: 2px solid #4a5568;
    }
    
    .day-option input[type="radio"]:checked + .day-label,
    .zone-option input[type="radio"]:checked + .zone-label {
        border: 2px solid #1a202c;
    }
}

@media (hover: none) and (pointer: coarse) {
    .btn:hover {
        transform: none;
        box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
    }
    
    .day-label:hover, .zone-label:hover {
        transform: none;
        box-shadow: none;
        background: rgba(255, 255, 255, 0.7);
    }
    
    .cancel-item:hover {
        transform: none;
        box-shadow: 0 4px 20px rgba(0,0,0,0.05);
    }
    
    .stat-card:hover, .zone-stat-card:hover, .user-item:hover {
        transform: none;
    }
    
    .btn:active {
        transform: scale(0.97);
        transition: transform 0.1s ease;
    }
    
    .day-label:active, .zone-label:active {
        transform: scale(0.97);
        transition: transform 0.1s ease;
    }
}

@media (max-width: 390px) {
    .container {
        padding: 20px 16px;
    }
    
    h1 {
        font-size: 22px;
        padding: 30px 16px 20px;
    }
    
    .btn {
        font-size: 16px;
        padding: 20px;
    }
    
    .modal-content {
        padding: 20px 16px 30px;
    }
    
    .modal h2 {
        font-size: 20px;
    }
    
    .stats-summary {
        grid-template-columns: 1fr;
        gap: 8px;
    }
    
    .month-navigation {
        padding: 10px 16px;
        gap: 12px;
    }
    
    .current-month {
        font-size: 16px;
    }
}
/* 플로팅 메뉴 버튼 컨테이너 */
.floating-menu-container {
    position: fixed;
    bottom: 20px;
    right: 30px;
    z-index: 1000;
    display: flex;
    flex-direction: column-reverse;
    align-items: center;
    gap: 0;
}

/* 메인 메뉴 버튼 */
.floating-menu-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    border: none;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.4);
    backdrop-filter: blur(20px);
    border: 2px solid rgba(255, 255, 255, 0.2);
    position: relative;
    overflow: hidden;
}

.floating-menu-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
    transition: left 0.6s;
}

.floating-menu-btn:hover::before {
    left: 100%;
}

.floating-menu-btn:hover {
    transform: scale(1.1);
    box-shadow: 0 12px 35px rgba(102, 126, 234, 0.5);
}

/* 햄버거 아이콘 */
.hamburger-icon {
    width: 24px;
    height: 18px;
    position: relative;
    transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

.hamburger-line {
    position: absolute;
    left: 0;
    width: 100%;
    height: 3px;
    background: white;
    border-radius: 2px;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

.hamburger-line:nth-child(1) {
    top: 0;
}

.hamburger-line:nth-child(2) {
    top: 50%;
    transform: translateY(-50%);
}

.hamburger-line:nth-child(3) {
    bottom: 0;
}

/* 메뉴 열린 상태 */
.floating-menu-container.open .hamburger-icon {
    transform: rotate(90deg);
}

.floating-menu-container.open .hamburger-line:nth-child(1) {
    top: 50%;
    transform: translateY(-50%) rotate(45deg);
}

.floating-menu-container.open .hamburger-line:nth-child(2) {
    opacity: 0;
    transform: translateY(-50%) translateX(20px);
}

.floating-menu-container.open .hamburger-line:nth-child(3) {
    bottom: 50%;
    transform: translateY(50%) rotate(-45deg);
}

/* 서브 메뉴 버튼들 */
.sub-menu-btn {
    width: 50px;
    height: 50px;
    border-radius: 50%;
    border: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 20px;
    transition: all 0.5s cubic-bezier(0.68, -0.55, 0.265, 1.55);
    backdrop-filter: blur(20px);
    border: 2px solid rgba(255, 255, 255, 0.3);
    opacity: 0;
    transform: scale(0);
    pointer-events: none;
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
    position: absolute;
}

/* 다크모드 토글 버튼 */
.dark-mode-btn {
    background: rgba(255, 255, 255, 0.95);
    color: #f59e0b;
    bottom: 5px;
    right: 5px;
}

.dark-mode-btn:hover {
    background: white;
    transform: scale(1.1);
    box-shadow: 0 8px 25px rgba(245, 158, 11, 0.3);
}

/* 홈 버튼 */
.home-btn {
    background: rgba(255, 255, 255, 0.95);
    color: #10b981;
    bottom: 5px;
    right: 5px;
}

.home-btn:hover {
    background: white;
    transform: scale(1.1);
    box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
}

/* 메뉴 열린 상태 - 서브 버튼들 애니메이션 */
.floating-menu-container.open .sub-menu-btn {
    opacity: 1;
    pointer-events: auto;
}

/* 홈 버튼 (왼쪽으로) */
.floating-menu-container.open .home-btn {
    transform: translateY(0px) translateX(-70px) scale(1);
    transition-delay: 0.15s;
}

/* 모바일 반응형 */
@media (max-width: 768px) {
    .floating-menu-container {
        bottom: 15px;
        right: 20px;
        gap: 0;
    }
    
    .floating-menu-btn {
        width: 56px;
        height: 56px;
    }
    
    .sub-menu-btn {
        width: 46px;
        height: 46px;
        font-size: 18px;
    }
    
    .dark-mode-btn, .home-btn {
        bottom: 5px;
        right: 5px;
    }
    
    .floating-menu-container.open .home-btn {
        transform: translateY(0px) translateX(-65px) scale(1);
    }
    
    .hamburger-icon {
        width: 22px;
        height: 16px;
    }
    
    .hamburger-line {
        height: 2.5px;
    }
}

/* 안전 영역 지원 */
@supports (padding: max(0px)) {
    .floating-menu-container {
        bottom: max(20px, calc(env(safe-area-inset-bottom) + 10px));
        right: max(30px, calc(env(safe-area-inset-right) + 20px));
    }
}

/* 애니메이션 감소 설정 */
@media (prefers-reduced-motion: reduce) {
    .floating-menu-btn,
    .sub-menu-btn,
    .hamburger-icon,
    .hamburger-line {
        transition-duration: 0.01ms !important;
        animation-duration: 0.01ms !important;
    }
}

/* 고대비 모드 지원 */
@media (prefers-contrast: high) {
    .floating-menu-btn,
    .sub-menu-btn {
        border: 3px solid #2d3748;
    }
    
    body.dark-mode .floating-menu-btn,
    body.dark-mode .sub-menu-btn {
        border: 3px solid #e2e8f0;
    }
}
.time-selection-container {
    display: none;
}

.time-selection-container.show {
    display: block;
    animation: slideUp 0.4s cubic-bezier(0.4, 0, 0.2, 1);
}

.time-selection {
    display: grid;
    grid-template-columns: 1fr;
    gap: 12px;
    margin-top: 16px;
}

.time-option {
    position: relative;
}

.time-option input[type="radio"] {
    display: none;
}
#noticeViewContent {
    white-space: pre-line;
    line-height: 1.6;
}

.time-label {
    display: block;
    padding: 20px 16px;
    border: none;
    border-radius: 16px;
    text-align: center;
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(102, 126, 234, 0.1);
    font-weight: 600;
    font-size: var(--label-font-size);
    position: relative;
    overflow: hidden;
}

.time-label::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    opacity: 0;
    transition: opacity 0.3s ease;
    z-index: -1;
}

.time-option input[type="radio"]:checked + .time-label {
    color: white;
    border-color: #667eea;
    box-shadow: 0 8px 30px rgba(102, 126, 234, 0.4);
    transform: translateY(-2px);
}

.time-option input[type="radio"]:checked + .time-label::before {
    opacity: 1;
}

.time-label:active {
    transform: scale(0.98);
}

.time-label.disabled {
    background: #ff6b6b !important;
    color: white !important;
    border-color: #ff6b6b !important;
    cursor: not-allowed !important;
}

.time-capacity-info {
    font-size: var(--small-font-size);
    margin-top: 6px;
    color: #718096;
    font-weight: 500;
}
.time-slot-header {
    font-size: var(--small-font-size);
    color: #667eea;
    font-weight: 700;
    margin-bottom: 6px;
}

.time-option input[type="radio"]:checked + .time-label .time-capacity-info {
    color: rgba(255, 255, 255, 0.9);
}

@media (max-width: 768px) {
    .time-selection {
        grid-template-columns: 1fr;
        gap: 10px;
    }
}
/* 시간대 설정 컨테이너 */
.time-slot-settings {
    background: rgba(255, 255, 255, 0.8);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    padding: 20px;
    margin: 16px 0;
    border: 1px solid rgba(102, 126, 234, 0.1);
    min-height: 60px;
    max-height: 300px;
    overflow-y: auto;
}

.time-slot-setting {
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(15px);
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 12px;
    border: 1px solid rgba(102, 126, 234, 0.1);
    box-shadow: 0 2px 8px rgba(0,0,0,0.04);
    transition: all 0.3s ease;
}

.time-slot-setting:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 15px rgba(0,0,0,0.08);
}

.time-slot-row {
    display: grid;
    grid-template-columns: 1fr 1fr auto auto;
    gap: 12px;
    align-items: center;
}

.time-input-group {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.time-input-label {
    font-size: var(--small-font-size);
    color: #667eea;
    font-weight: 600;
    margin: 0;
}

.time-picker-container {
    display: flex;
    gap: 8px;
    align-items: center;
}

.time-picker {
    display: flex;
    align-items: center;
    gap: 6px;
    background: rgba(255, 255, 255, 0.9);
    border: 1px solid rgba(102, 126, 234, 0.2);
    border-radius: 8px;
    padding: 8px 12px;
    font-size: var(--label-font-size);
}

.time-select {
    border: none;
    background: transparent;
    font-size: var(--label-font-size);
    font-weight: 600;
    color: #2d3748;
    cursor: pointer;
}

.time-select:focus {
    outline: none;
}

.capacity-input {
    width: 70px !important;
    padding: 12px !important;
    text-align: center;
    font-weight: 600;
}

.btn.remove-time {
    background: linear-gradient(135deg, #fc8181 0%, #e53e3e 100%);
    color: white;
    border: none;
    border-radius: 8px;
    padding: 10px 14px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 600;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(252, 129, 129, 0.3);
    min-width: 60px;
}

.btn.remove-time:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 18px rgba(252, 129, 129, 0.4);
}

.btn.toggle-active {
    background: linear-gradient(135deg, #68d391 0%, #38a169 100%);
    color: white;
    border: none;
    border-radius: 8px;
    padding: 10px 14px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 600;
    transition: all 0.3s ease;
    box-shadow: 0 4px 12px rgba(104, 211, 145, 0.3);
    min-width: 60px;
}

.btn.toggle-active:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 18px rgba(104, 211, 145, 0.4);
}

.btn.toggle-active.inactive {
    background: linear-gradient(135deg, #a0aec0 0%, #718096 100%);
    box-shadow: 0 4px 12px rgba(160, 174, 192, 0.3);
}

.time-slot-controls {
    display: flex;
    justify-content: center;
    margin: 20px 0;
}

.zone-add-controls {
    display: flex;
    justify-content: center;
    margin-top: 30px;
    padding-top: 20px;
    border-top: 1px solid rgba(102, 126, 234, 0.1);
}

.empty-time-slots {
    text-align: center;
    color: #a0aec0;
    font-style: italic;
    padding: 30px 20px;
    font-size: 14px;
}

/* 모바일 반응형 */
@media (max-width: 768px) {
    .time-slot-row {
        grid-template-columns: 1fr;
        gap: 16px;
    }
    
    .time-input-group {
        grid-column: 1;
    }
    
    .capacity-input {
        width: 100% !important;
    }
    
    .time-picker-container {
        justify-content: space-between;
    }
    
    .btn.remove-time,
    .btn.toggle-active {
        width: 100%;
        margin-top: 8px;
    }
}
.warning {
    font-size: 12px;
    color: #e53e3e;
    margin-top: 4px;
    font-weight: 500;
}
/* 글자 크기 조정 버튼 */
.font-size-btn {
    background: rgba(255, 255, 255, 0.95);
    color: #667eea;
    bottom: 5px;
    right: 5px;
    font-weight: bold;
    font-size: 18px;
}

.font-size-btn:hover {
    background: white;
    transform: scale(1.1);
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
}

/* 글자 크기 슬라이더 컨테이너 */
.font-size-slider-container {
    position: absolute;
    bottom: 70px;
    right: 10px;
    width: 200px;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: blur(20px);
    border-radius: 16px;
    padding: 15px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
    border: 1px solid rgba(255, 255, 255, 0.3);
    opacity: 0;
    transform: translateY(20px) scale(0.9);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    pointer-events: none;
    z-index: 1001;
}

.font-size-slider-container.show {
    opacity: 1;
    transform: translateY(0) scale(1);
    pointer-events: auto;
}

/* 슬라이더 헤더 */
.slider-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 12px;
    font-weight: 600;
    color: #2d3748;
}

.close-slider {
    background: none;
    border: none;
    font-size: 20px;
    cursor: pointer;
    color: #a0aec0;
    padding: 0;
    width: 24px;
    height: 24px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
}

.close-slider:hover {
    background: rgba(0, 0, 0, 0.05);
    color: #4a5568;
}

/* 슬라이더 스타일 */
#fontSizeRange {
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: #e2e8f0;
    outline: none;
    appearance: none;  
    -webkit-appearance: none;
}

#fontSizeRange::-webkit-slider-thumb {
    -webkit-appearance: none;
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #667eea;
    cursor: pointer;
    box-shadow: 0 2px 6px rgba(102, 126, 234, 0.4);
}

#fontSizeRange::-moz-range-thumb {
    width: 18px;
    height: 18px;
    border-radius: 50%;
    background: #667eea;
    cursor: pointer;
    border: none;
    box-shadow: 0 2px 6px rgba(102, 126, 234, 0.4);
}

.slider-value {
    text-align: center;
    margin-top: 8px;
    font-size: 13px;
    color: #718096;
    font-weight: 600;
}

/* 플로팅 메뉴 열린 상태에서의 글자 크기 버튼 위치 조정 */
.floating-menu-container.open .font-size-btn {
    transform: translateY(-70px) translateX(0px) scale(1);
    transition-delay: 0.05s;
}

.floating-menu-container.open .home-btn {
    transform: translateY(0px) translateX(-70px) scale(1);
    transition-delay: 0.15s;
}

/* 반응형 디자인 */
@media (max-width: 768px) {
    .font-size-slider-container {
        width: 180px;
        right: 5px;
    }
    
    .floating-menu-container.open .font-size-btn {
        transform: translateY(-65px) translateX(0px) scale(1);
    }
    
    .floating-menu-container.open .home-btn {
        transform: translateY(0px) translateX(-65px) scale(1);
    }
}
/* 스케줄 설정 스타일 */
.schedule-item {
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(10px);
    border-radius: 16px;
    padding: 20px;
    margin-bottom: 16px;
    border: 1px solid rgba(102, 126, 234, 0.1);
    box-shadow: 0 4px 20px rgba(0,0,0,0.05);
}

.schedule-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 16px;
}

.schedule-title {
    font-weight: 700;
    color: #2d3748;
    font-size: 16px;
}

.day-selection-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
    margin-bottom: 16px;
}

.day-checkbox {
    display: flex;
    align-items: center;
    gap: 8px;
}

.day-checkbox input[type="checkbox"] {
    width: auto;
    margin: 0;
}

.time-slot-settings {
    background: rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(5px);
    border-radius: 12px;
    padding: 16px;
    margin-top: 16px;
    border: 1px solid rgba(102, 126, 234, 0.1);
}

.time-slot-item {
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(5px);
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 12px;
    border: 1px solid rgba(102, 126, 234, 0.1);
}

.time-slot-controls {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-top: 12px;
}

.remove-schedule {
    background: linear-gradient(135deg, #fc8181 0%, #e53e3e 100%);
    color: white;
    border: none;
    border-radius: 8px;
    padding: 8px 12px;
    cursor: pointer;
    font-size: 12px;
    font-weight: 600;
}

/* 요일 탭 스타일 */
.day-tabs {
    display: flex;
    overflow-x: auto;
    gap: 8px;
    margin-bottom: 20px;
    padding: 0 10px;
    scrollbar-width: none; /* Firefox */
}

.day-tabs::-webkit-scrollbar {
    display: none; /* Chrome, Safari */
}

.day-tab {
    flex: 0 0 auto;
    padding: 12px 16px;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.8);
    border: 1px solid rgba(102, 126, 234, 0.2);
    cursor: pointer;
    font-weight: 600;
    font-size: 14px;
    white-space: nowrap;
    transition: all 0.3s ease;
}

.day-tab:hover {
    background: rgba(102, 126, 234, 0.1);
}

.day-tab.active {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
}

.day-tab.empty {
    opacity: 0.5;
    cursor: not-allowed;
}

.tab-content {
    min-height: 200px;
}
.day-tabs {
    scroll-behavior: smooth;
    -webkit-overflow-scrolling: touch;
}
/* 날씨 버튼 스타일 */
.weather-btn {
    background: rgba(255, 255, 255, 0.95);
    color: #3b82f6;
    bottom: 5px;
    right: 5px;
}

.weather-btn:hover {
    background: white;
    transform: scale(1.1);
    box-shadow: 0 8px 25px rgba(59, 130, 246, 0.3);
}

/* 플로팅 메뉴 열린 상태에서의 버튼 위치 조정 */
.floating-menu-container.open .weather-btn {
    transform: translateY(-140px) translateX(0px) scale(1);
    transition-delay: 0.05s;  /* 가장 먼저 나타나도록 */
}

.floating-menu-container.open .font-size-btn {
    transform: translateY(-70px) translateX(0px) scale(1);
    transition-delay: 0.1s;   /* 두 번째로 나타나도록 */
}

.floating-menu-container.open .home-btn {
    transform: translateY(0px) translateX(-70px) scale(1);
    transition-delay: 0.2s;   /* 마지막으로 나타나도록 */
}
@media (max-width: 768px) {
    .floating-menu-container.open .weather-btn {
        transform: translateY(-130px) translateX(0px) scale(1);
    }
    
    .floating-menu-container.open .font-size-btn {
        transform: translateY(-65px) translateX(0px) scale(1);
    }
    
    .floating-menu-container.open .home-btn {
        transform: translateY(0px) translateX(-65px) scale(1);
    }
}
/* 날씨 모달 오버레이 스타일 */
.weather-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.6);
    display: flex;
    justify-content: center;
    align-items: flex-end;
    z-index: 1000;
    opacity: 0;
    transition: opacity 0.3s ease-in-out;
}

.weather-modal-overlay.active {
    opacity: 1;
}

/* 날씨 모달 컨텐츠 스타일 (아래에서 위로 올라오는 애니메이션) */
.weather-modal-content {
    background-color: #ffffff;
    width: 100%;
    max-width: 800px;
    max-height: 80vh;
    border-radius: 20px 20px 0 0;
    box-shadow: 0 -5px 25px rgba(0,0,0,0.2);
    padding: 25px;
    display: flex;
    flex-direction: column;
    transform: translateY(100%);
    transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
}

.weather-modal-content.active {
    transform: translateY(0);
}

/* 모달 헤더 (제목, 닫기 버튼) */
.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    color: #333;
    padding-bottom: 15px;
    border-bottom: 1px solid #eee;
}

.modal-header h2 {
    margin: 0;
    font-size: 1.5em;
}

.close-button {
    background: none;
    border: none;
    font-size: 2.5em;
    line-height: 1;
    cursor: pointer;
    color: #aaa;
    transition: color 0.2s;
}

.close-button:hover {
    color: #333;
}

/* 날씨 카드 컨테이너 (스크롤 가능) */
.forecast-container {
    display: flex;
    overflow-x: auto; /* 작은 화면에서 가로 스크롤 가능 */
    gap: 15px;
    padding: 10px 5px;
}
/* 스크롤바 디자인 */
.forecast-container::-webkit-scrollbar {
  height: 8px;
}
.forecast-container::-webkit-scrollbar-thumb {
  background: #ccc;
  border-radius: 4px;
}

/* 개별 날씨 카드 */
.forecast-card {
    flex: 0 0 130px; /* 카드의 너비를 고정 */
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 15px;
    background-color: #f8f9fa;
    border-radius: 15px;
    border: 1px solid #e9ecef;
    text-align: center;
}

.forecast-date {
    font-weight: bold;
    margin-bottom: 5px;
    color: #555;
}
.forecast-date .day-of-week {
    font-size: 1.2em;
    color: #007bff;
}
.forecast-date .month-day {
    font-size: 0.9em;
    color: #6c757d;
}

.weather-icon {
    width: 70px;
    height: 70px;
}

.weather-description {
    font-size: 0.9em;
    color: #495057;
    margin-bottom: 10px;
    height: 30px; /* 설명이 길어도 높이를 유지 */
}

.temperature {
    font-size: 1em;
    width: 100%;
    display: flex;
    justify-content: space-around;
}
.temp-max {
    color: #e44d26;
    font-weight: bold;
}
.temp-min {
    color: #269de4;
}
.weather-icon-kma {
    font-size: 4em; /* 이모지 아이콘 크기 */
    line-height: 1;
    margin: 10px 0;
}
/* 기존 모달 컨텐츠 스타일 유지 */
.weather-modal-content {
    background-color: #ffffff; /* 기본 배경 흰색 유지 */
    width: 100%;
    max-width: 800px;
    max-height: 80vh;
    border-radius: 20px 20px 0 0;
    box-shadow: 0 -5px 25px rgba(0,0,0,0.2);
    padding: 25px;
    display: flex;
    flex-direction: column;
    transform: translateY(100%);
    transition: transform 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
    /* 여기에 배경 이미지 관련 속성 추가 */
    background-size: cover; /* 배경 이미지가 모달 전체를 덮도록 */
    background-position: center bottom; /* 배경 이미지 위치 */
    color: #333; /* 기본 글자색 */
    position: relative; /* 의사 요소를 위한 기준점 */
}

/* 모달 컨텐츠 배경 이미지 오버레이 (텍스트 가독성을 높임) */
.weather-modal-content::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(255, 255, 255, 0.5); /* 반투명 흰색 오버레이 */
    border-radius: 20px 20px 0 0;
    z-index: 0; /* 컨텐츠 아래에 위치 */
    pointer-events: none;
}

.weather-modal-content > *:not(::before) {
    position: relative;
    z-index: 1; /* 컨텐츠가 오버레이 위에 오도록 */
}

/* 날씨별 모달 배경 이미지 */
.weather-modal-content.clear-bg {
    background-image: url('https://images.unsplash.com/photo-1596482181554-46c05d7b5b7c?q=80&w=2940&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D'); /* 맑음 */
    color: #222;
}
.weather-modal-content.cloudy-bg {
    background-image: url('https://images.unsplash.com/photo-1501612781498-8a211e2f5f7a?q=80&w=2940&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D'); /* 구름많음 */
    color: #222;
}
.weather-modal-content.overcast-bg {
    background-image: url('https://images.unsplash.com/photo-1534082531317-a1dc0c634c03?q=80&w=2940&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D'); /* 흐림 */
    color: #fff;
}
.weather-modal-content.rain-bg {
    background-image: url('https://images.unsplash.com/photo-1534082531317-a1dc0c634c03?q=80&w=2940&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D'); /* 비 */
    color: #fff;
}
.weather-modal-content.sleet-bg { /* 비/눈 */
    background-image: url('https://images.unsplash.com/photo-1601614051016-17b738941011?q=80&w=2942&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D'); 
    color: #fff;
}
.weather-modal-content.snow-bg {
    background-image: url('https://images.unsplash.com/photo-1549477025-a1c6a014d48c?q=80&w=2940&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D'); /* 눈 */
    color: #fff;
}
.weather-modal-content.shower-bg { /* 소나기 */
    background-image: url('https://images.unsplash.com/photo-1627993074360-1e5f8f8f0f0f?q=80&w=2940&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D');
    color: #fff;
}
.weather-modal-content.default-bg {
    background-image: url('https://images.unsplash.com/photo-1500382017468-b27b3d0a6311?q=80&w=2940&auto=format&fit=crop&ixlib=rb-4.0.3&ixid=M3wxMjA3fDB8MHxwaG90by1wYWdlfHx8fGVufDB8fHx8fA%3D%3D'); /* 기본 배경 */
    color: #333;
}

/* 모달 헤더 (배경에 따라 글자색 조정) */
.modal-header h2, .close-button {
    color: inherit; /* 부모 요소의 글자색을 상속 */
    text-shadow: 1px 1px 3px rgba(0,0,0,0.2); /* 가독성 향상 */
}


/* 개별 날씨 카드 스타일 (배경 그라데이션 추가) */
.forecast-card {
    flex: 0 0 130px; 
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 15px;
    /* background-color: #f8f9fa; */ /* 기존 배경색 제거 */
    border-radius: 15px;
    border: 1px solid rgba(255, 255, 255, 0.3); /* 테두리 연하게 */
    text-align: center;
    box-shadow: 0 4px 10px rgba(0,0,0,0.1);
    backdrop-filter: blur(5px); /* 배경을 흐리게 */
    color: #f8f9fa; /* 카드 내부 글자색 밝게 */
    transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
}

.forecast-card:hover {
    transform: translateY(-5px);
    box-shadow: 0 8px 15px rgba(0,0,0,0.2);
}

/* 날씨별 카드 배경 그라데이션 */
.clear-bg-card { background: linear-gradient(135deg, #FFD700, #FFA500); } /* 맑음: 황금색 */
.cloudy-bg-card { background: linear-gradient(135deg, #A9A9A9, #778899); } /* 구름많음: 회색 */
.overcast-bg-card { background: linear-gradient(135deg, #696969, #4F4F4F); } /* 흐림: 진회색 */
.rain-bg-card { background: linear-gradient(135deg, #4682B4, #2F4F4F); } /* 비: 파란색 */
.sleet-bg-card { background: linear-gradient(135deg, #87CEEB, #6A5ACD); } /* 비/눈: 하늘색-보라 */
.snow-bg-card { background: linear-gradient(135deg, #B0E0E6, #ADD8E6); } /* 눈: 연한 하늘색 */
.shower-bg-card { background: linear-gradient(135deg, #40E0D0, #20B2AA); } /* 소나기: 청록색 */
.default-bg-card { background: linear-gradient(135deg, #87CEEB, #6A5ACD); } /* 기본: 하늘색 */

/* 카드 내부 글자색 조정 */
.forecast-date .day-of-week, .forecast-date .month-day,
.weather-description, .temperature, .temp-max, .temp-min {
    color: inherit; /* 부모인 카드 색상 상속 */
    text-shadow: 1px 1px 2px rgba(0,0,0,0.2); /* 가독성 향상 */
}

/* 이모지 아이콘 크기 */
.weather-icon-kma {
    font-size: 4em; 
    line-height: 1;
    margin: 10px 0;
    text-shadow: 2px 2px 5px rgba(0,0,0,0.3); /* 아이콘에도 그림자 추가 */
}

/* 스크롤바 디자인 (조금 더 세련되게) */
.forecast-container::-webkit-scrollbar {
  height: 8px;
  background: rgba(255, 255, 255, 0.2);
  border-radius: 10px;
}
.forecast-container::-webkit-scrollbar-thumb {
  background: rgba(255, 255, 255, 0.6);
  border-radius: 4px;
}
.forecast-container::-webkit-scrollbar-thumb:hover {
  background: rgba(255, 255, 255, 0.8);
}
/* --- 어두운 배경용 글자색 테마 --- */

/* 모달 헤더 (제목, 닫기 버튼) */
.modal-header h2, .close-button {
    color: #0e00a8;
    text-shadow: none;
}

/* 카드 날짜 (요일 강조) */
.forecast-date .day-of-week {
    color: #87CEFA; /* 밝은 하늘색으로 요일 강조 */
}

.forecast-date .month-day {
    color: #dcdcdc; /* 날짜는 연한 회색 */
}

/* 최고/최저 기온 색상 대비 */
.temp-max {
    color: #FFB6C1; /* 최고기온: 밝은 핑크 */
}

.temp-min {
    color: #ADD8E6; /* 최저기온: 밝은 하늘색 */
}
/* 새로고침 버튼 스타일 */
.refresh-btn {
    background: linear-gradient(135deg, #e53e3e 0%, #c53030 100%); /* 붉은색 그라데이션 */
    color: white;
    bottom: 5px;
    right: 5px;
}

.refresh-btn:hover {
    background: linear-gradient(135deg, #f56565 0%, #e53e3e 100%); /* 호버 시 더 밝은 붉은색 */
    transform: scale(1.1);
    box-shadow: 0 8px 25px rgba(245, 101, 101, 0.4);
}

/* 새로고침 버튼 위치 조정 */
.floating-menu-container.open .refresh-btn {
    transform: translateY(0px) translateX(-130px) scale(1);
    transition-delay: 0.175s;
}
/* 메모 버튼 */
.memo-button {
    position: fixed;
    top: 20px;
    left: 20px;
    width: 52px;
    height: 52px;
    border-radius: 50%;
    border: none;
    background: rgba(255, 255, 255, 0.95);
    color: #667eea;
    cursor: pointer;
    font-size: 20px;
    z-index: 999;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
    backdrop-filter: blur(20px);
    border: 1px solid rgba(255, 255, 255, 0.3);
    box-shadow: 0 4px 20px rgba(0,0,0,0.1);
}

.memo-button:hover {
    transform: scale(1.1);
    box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3);
}

/* 메모 탭 */
.memo-tabs {
    display: flex;
    overflow-x: auto;
    gap: 8px;
    margin-bottom: 20px;
    padding: 0 10px;
    scrollbar-width: none;
}

.memo-tabs::-webkit-scrollbar {
    display: none;
}

.memo-tab {
    flex: 0 0 auto;
    padding: 12px 16px;
    border-radius: 12px;
    background: rgba(255, 255, 255, 0.8);
    border: 1px solid rgba(102, 126, 234, 0.2);
    cursor: pointer;
    font-weight: 600;
    font-size: 14px;
    white-space: nowrap;
    transition: all 0.3s ease;
}

.memo-tab:hover {
    background: rgba(102, 126, 234, 0.1);
}

.memo-tab.active {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
}

/* 메모 콘텐츠 */
.memo-content {
    max-height: 400px;
    overflow-y: auto;
    margin-bottom: 20px;
}

.memo-item {
    background: rgba(255, 255, 255, 0.9);
    backdrop-filter: blur(10px);
    border-radius: 12px;
    padding: 16px;
    margin-bottom: 12px;
    border: 1px solid rgba(102, 126, 234, 0.1);
    box-shadow: 0 4px 20px rgba(0,0,0,0.05);
}

.memo-content-text {
    margin-bottom: 10px;
    line-height: 1.6;
}

.memo-meta {
    display: flex;
    justify-content: space-between;
    font-size: 12px;
    color: #718096;
}

.memo-actions {
    margin-top: 10px;
    text-align: right;
}
.stats-tabs {
    display: flex;
    margin-bottom: 20px;
    border-bottom: 1px solid #e2e8f0;
}

.stats-tab {
    padding: 10px 20px;
    background: none;
    border: none;
    cursor: pointer;
    font-weight: 600;
    color: #718096;
    border-bottom: 3px solid transparent;
}

.stats-tab.active {
    color: #667eea;
    border-bottom-color: #667eea;
}

#chartContainer {
    height: 300px;
    margin-bottom: 20px;
}
/* 메신저 모달 스타일 개선 */
/* 메신저 모달 전체 스타일 */
#messengerModal .modal-content {
  position: fixed;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 90%;
  max-width: 500px;
  height: auto; /* 고정 높이 대신 auto로 변경 */
  max-height: 80vh; /* 최대 높이 제한은 유지 */
  border-radius: 16px;
  padding: 20px;
  display: flex;
  flex-direction: column;
  animation: modalFadeIn 0.3s ease;
  overflow: hidden; /* 모달 내용이 넘치면 숨기기 */
}

@keyframes slideUpFromBottom {
  from {
    transform: translateY(-100%);
  }
  to {
    transform: translateY(0);
  }
}

/* 메시지 입력 영역 */
.message-input-container {
  display: flex;
  gap: 8px;
  margin-top: 15px;
  align-items: flex-end; /* 하단 정렬 */
}

#messageInput {
  flex: 1;
  padding: 12px 16px;
  border-radius: 24px;
  border: 1px solid #e0e0e0;
  resize: none;
  min-height: 24px;
  max-height: 100px;
  font-size: 16px;
  line-height: 1.4;
  box-shadow: 0 2px 6px rgba(0, 0, 0, 0.05);
}

#sendMessageBtn {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border: none;
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  box-shadow: 0 2px 6px rgba(102, 126, 234, 0.3);
  transition: all 0.2s ease;
  flex-shrink: 0; /* 크기 고정 */
}
#sendMessageBtn:active {
  transform: scale(0.95);
}

/* 메시지 컨테이너 스타일 */
#messagesContainer {
  flex: 1;
  overflow-y: auto; /* 세로 스크롤만 활성화 */
  padding: 10px 5px;
  display: flex;
  flex-direction: column;
  gap: 12px;
  margin-bottom: 15px;
  max-height: 50vh; /* 높이 제한 */
  min-height: 200px; /* 최소 높이 설정 */
}
body.modal-open {
  overflow: hidden;
}


/* 개별 메시지 스타일 */
.message {
  max-width: 80%;
  padding: 10px 14px;
  border-radius: 18px;
  position: relative;
  word-break: break-word;
  animation: fadeIn 0.2s ease;
}

@keyframes fadeIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* 내 메시지 스타일 */
.my-message {
  align-self: flex-end;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  color: white;
  border-top-right-radius: 4px;
}

/* 다른 사람 메시지 스타일 */
.other-message {
  align-self: flex-start;
  background: #f1f1f1;
  color: #333;
  border-top-left-radius: 4px;
}

/* 메시지 정보 (작성자, 시간) */
.message-info {
  display: flex;
  justify-content: space-between;
  margin-top: 4px;
  font-size: 11px;
  opacity: 0.8;
}

.my-message .message-info {
  color: rgba(255, 255, 255, 0.8);
}

.other-message .message-info {
  color: rgba(0, 0, 0, 0.6);
}
@media (max-width: 768px) {
  .message-input-container {
    padding: 0 10px;
  }
  
  #messageInput {
    font-size: 16px; /* iOS zoom 방지 */
  }
}

/* 모바일 최적화 */
@media (max-width: 480px) {
   #messengerModal .modal-content {
    top: 0;
    left: 0;
    transform: none;
    width: 100%;
    max-width: none;
    max-height: 100vh;
    height: 100vh;
    border-radius: 0 0 16px 16px;
    padding: 12px;
  }
  
  #messagesContainer {
    max-height: calc(100vh - 140px);
  }
}


/* 스크롤바 스타일링 */
#messagesContainer::-webkit-scrollbar {
  width: 5px;
}

#messagesContainer::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 10px;
}

#messagesContainer::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 10px;
}

#messagesContainer::-webkit-scrollbar-thumb:hover {
  background: #a8a8a8;
}
    </style>
</head>
<body>
    <div class="container">
        <!-- 로그인 페이지 -->
        <div class="login-page" id="loginPage">
            <h1>불광서부회중<br>전시대 봉사 신청</h1>

            <div class="login-form">
                <div class="form-group">
                    <label for="loginName">이름</label>
                    <input type="text" id="loginName" placeholder="이름을 입력하세요" required>
                </div>
                <button type="button" class="btn" onclick="login()">확인</button>
            </div>
        </div>
        <!-- 메신저 모달 -->
<div id="messengerModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeMessengerModal()">&times;</span>
        <h2>단체 채팅</h2>

        <div id="messengerInfo" style="margin-bottom: 15px; padding: 10px; background: #f5f5f5; border-radius: 8px;">
            <!-- 채팅방 정보가 여기에 표시됩니다 -->
        </div>

        <div id="messagesContainer">
            <!-- 메시지들이 여기에 표시됩니다 -->
        </div>

        <div class="message-input-container">
            <textarea id="messageInput" placeholder="메시지를 입력하세요..." onkeypress="handleMessageKeyPress(event)"></textarea>
            <button id="sendMessageBtn" onclick="sendMessage()">
                <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                    <path d="M2 21L23 12L2 3V10L17 12L2 14V21Z" fill="white"/>
                </svg>
            </button>
        </div>
    </div>
</div>


        <!-- 일반 사용자 메인 페이지 -->
        <div class="main-page" id="mainPage">
            <h1>불광서부회중<br>전시대 봉사 신청</h1>

            <div class="user-info" id="userInfo"></div>

            <div class="action-buttons">
                <button type="button" class="btn" onclick="openRegistrationModal()">전시대 봉사 신청</button>
                <button type="button" class="btn secondary" onclick="openCancelModal()">신청 취소</button>
            </div>
        </div>

        <!-- 관리자 페이지 -->
        <div class="admin-page" id="adminPage">
            <h1>관리자 모드</h1>

            <div class="admin-info">관리자님 환영합니다!</div>

            <div class="admin-actions">
                <button type="button" class="btn admin" onclick="openUserManagementModal()">전도인 관리</button>
                <button type="button" class="btn admin" onclick="openZoneManagementModal()">구역 관리</button>
                <button type="button" class="btn admin" onclick="openNoticeManagementModal()">공지사항 관리</button>
                <button type="button" class="btn secondary" onclick="openStatsModal()">데이터 통계</button>
            </div>
        </div>

        <!-- 신청 현황 -->
<div class="applicants-list">
    <h3>신청 현황</h3>
    <div class="day-tabs" id="dayTabs">
        <!-- 동적으로 생성될 요일 탭들 -->
    </div>
    <div class="tab-content" id="applicantsList">
        <!-- 선택된 요일의 신청현황만 표시 -->
    </div>
</div>
        <div class="version-info">v3.1</div>
    </div>
    <!-- 고정 공지 버튼 -->
<button id="noticeButton" class="notice-button inactive" onclick="handleNoticeButtonClick()" style="display: none;">
    📢
    <div id="noticeBadge" class="notice-badge"></div>
</button>
<!-- 기존 코드에 추가 -->
<button id="memoButton" class="memo-button" onclick="openMemoModal()">📝</button>

<!-- 메모 모달 -->
<div id="memoModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeMemoModal()">&times;</span>
        <h2>구역별 유의사항</h2>
        
        <div class="memo-tabs" id="memoTabs">
            <!-- 구역 탭이 여기에 생성됩니다 -->
        </div>
        
        <div class="memo-content" id="memoContent">
            <!-- 선택된 구역의 메모들이 표시됩니다 -->
        </div>
        
        <button class="btn" onclick="openEditMemoModal()">+ 새 메모 추가</button>
    </div>
</div>

<!-- 메모 작성/수정 모달 -->
<div id="editMemoModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeEditMemoModal()">&times;</span>
        <h2 id="editMemoTitle">새 메모 작성</h2>
        
        <form id="editMemoForm">
            <div class="form-group">
                <label for="memoZone">구역 선택</label>
                <select id="memoZone" required>
                    <!-- 구역 옵션이 여기에 생성됩니다 -->
                </select>
            </div>
            
            <div class="form-group">
                <label for="memoContentInput">메모 내용</label>
                <textarea id="memoContentInput" rows="5" required placeholder="구역별 유의사항을 입력하세요"></textarea>
            </div>
            
            <input type="hidden" id="memoId">
            
            <div class="form-buttons">
                <button type="submit" class="btn">저장</button>
                <button type="button" class="btn danger" id="deleteMemoBtn" style="display:none;" onclick="deleteMemo()">삭제</button>
            </div>
        </form>
    </div>
</div>


    <!-- 신청 모달 -->
    <div id="registrationModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeRegistrationModal()">&times;</span>
            <h2>전시대 봉사 신청</h2>

            <form id="registrationForm">
                <div class="form-group">
                    <label>요일 선택</label>
                    <div class="day-selection">
                        <div class="day-option">
                            <input type="radio" id="monday" name="day" value="월요일">
                            <label for="monday" class="day-label" data-day="월요일">
                                월요일
                                <div class="date-info" id="monday-date"></div>
                            </label>
                        </div>
                        <div class="day-option">
                            <input type="radio" id="tuesday" name="day" value="화요일">
                            <label for="tuesday" class="day-label" data-day="화요일">
                                화요일
                                <div class="date-info" id="tuesday-date"></div>
                            </label>
                        </div>
                        <div class="day-option">
                            <input type="radio" id="wednesday" name="day" value="수요일">
                            <label for="wednesday" class="day-label" data-day="수요일">
                                수요일
                                <div class="date-info" id="wednesday-date"></div>
                            </label>
                        </div>
                        <div class="day-option">
                            <input type="radio" id="thursday" name="day" value="목요일">
                            <label for="thursday" class="day-label" data-day="목요일">
                                목요일
                                <div class="date-info" id="thursday-date"></div>
                            </label>
                        </div>
                        <div class="day-option">
                            <input type="radio" id="friday" name="day" value="금요일">
                            <label for="friday" class="day-label" data-day="금요일">
                                금요일
                                <div class="date-info" id="friday-date"></div>
                            </label>
                        </div>
                        <div class="day-option">
                            <input type="radio" id="saturday" name="day" value="토요일">
                            <label for="saturday" class="day-label" data-day="토요일">
                                토요일
                                <div class="date-info" id="saturday-date"></div>
                            </label>
                        </div>
                        <div class="day-option">
                            <input type="radio" id="sunday" name="day" value="일요일">
                            <label for="sunday" class="day-label" data-day="일요일">
                                일요일
                                <div class="date-info" id="sunday-date"></div>
                            </label>
                        </div>
                    </div>
                </div>

                <div class="form-group zone-selection-container" id="zoneSelectionContainer">
                    <label>구역 선택</label>
                    <div class="zone-selection" id="zoneSelection">
                        <!-- 동적으로 생성됨 -->
                    </div>
                </div>
                <div class="form-group time-selection-container" id="timeSelectionContainer">
                    <label>시간 선택</label>
                    <div class="time-selection" id="timeSelection">
                         <!-- 동적으로 생성됨 -->
                    </div>
                </div>

                <button type="submit" class="btn">신청하기</button>
            </form>
        </div>
    </div>

    <!-- 신청 취소 모달 -->
    <div id="cancelModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeCancelModal()">&times;</span>
            <h2>신청 취소</h2>

            <div id="cancelList" class="cancel-list">
                <!-- 신청 내역이 여기에 표시됩니다 -->
            </div>
        </div>
    </div>

    <!-- 사용자 관리 모달 -->
    <div id="userManagementModal" class="modal">
        <div class="modal-content">
            <span class="close" onclick="closeUserManagementModal()">&times;</span>
            <h2>전도인 관리</h2>

            <div class="form-group">
                <label for="newUserName">새 전도인 추가</label>
                <input type="text" id="newUserName" placeholder="이름을 입력하세요" required>
                <button type="button" class="btn success small" onclick="addNewUser()" style="margin-top: 10px;">추가</button>
            </div>

            <div class="user-list">
                <h3>등록된 전도인</h3>
                <div id="userManagementList"></div>
            </div>
        </div>
    </div>

    <!-- 구역 관리 모달 -->
    <!-- 구역 관리 모달 -->
<div id="zoneManagementModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeZoneManagementModal()">&times;</span>
        <h2>구역 관리</h2>

        <div class="form-group">
            <label for="newZoneName">새 구역 추가</label>
            <input type="text" id="newZoneName" placeholder="구역 이름을 입력하세요" required>
        </div>

        <div class="form-group">
            <label>구역 일정 설정</label>
            <div id="schedulesContainer">
                <!-- 일정들이 여기에 동적으로 추가됩니다 -->
            </div>
            <button type="button" class="btn secondary small" onclick="addNewSchedule()" style="margin-top: 10px;">
                + 새 일정 추가
            </button>
        </div>

        <div class="zone-add-controls">
            <button type="button" class="btn success" onclick="addNewZone()">구역 추가</button>
        </div>

        <div class="user-list">
            <h3>등록된 구역</h3>
            <div id="zoneManagementList"></div>
        </div>
    </div>
</div>
<!-- 구역 수정 모달 -->
<div id="editZoneModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeEditZoneModal()">&times;</span>
        <h2>구역 수정</h2>

        <div class="form-group">
            <label for="editZoneName">구역 이름</label>
            <input type="text" id="editZoneName" placeholder="구역 이름을 입력하세요" required>
        </div>

        <div class="form-group">
            <label>구역 일정 설정</label>
            <div id="editSchedulesContainer">
                <!-- 일정들이 여기에 동적으로 추가됩니다 -->
            </div>
            <button type="button" class="btn secondary small" onclick="addNewScheduleToEdit()" style="margin-top: 10px;">
                + 새 일정 추가
            </button>
        </div>

        <div class="zone-add-controls">
            <button type="button" class="btn success" onclick="updateZone()">구역 수정</button>
        </div>
    </div>
</div>

    <!-- 데이터 통계 모달 -->
     
        <div id="statsModal" class="modal">
    <div class="modal-content large">
        <span class="close" onclick="closeStatsModal()">&times;</span>
        <h2 style="text-align:center;"> <span id="currentMonth"></span> </h2>
        <div class="stats-header">
            <div class="month-navigation">
                <button class="month-nav-btn" onclick="changeMonth(-1)">‹</button>
                <div class="current-month" id="currentMonth"></div>
                <button class="month-nav-btn" onclick="changeMonth(1)">›</button>
            </div>
        </div>
        
        <!-- 차트/표 전환 탭 추가 -->
        <div class="stats-tabs" style="display: flex; justify-content: center; margin-bottom: 15px;">
            <button class="stats-tab active" onclick="switchStatsView('table')">표 보기</button>
            <button class="stats-tab" onclick="switchStatsView('chart')">차트 보기</button>
        </div>
        
        <div class="stats-content">
            <div class="stats-buttons" style="display: flex; justify-content: center; gap: 20px; margin-bottom: 20px;">
                <button class="btn" onclick="displayZoneStats()">구역별 통계</button>
                <button class="btn" onclick="displayUserStats()">개인별 통계</button>
            </div>
            
            <!-- 차트를 표시할 컨테이너 추가 -->
            <div id="chartContainer" style="display: none; margin-bottom: 20px;">
                <canvas id="statsChart"></canvas>
            </div>
            
            <div id="statsDisplayArea" style="overflow-y: auto; max-height: 400px;"></div>
        </div>
    </div>
</div>
    <!-- 공지사항 관리 모달 -->
<div id="noticeManagementModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeNoticeManagementModal()">&times;</span>
        <h2>공지사항 관리</h2>

        <div class="form-group">
            <label for="noticeContent">공지 내용</label>
            <textarea id="noticeContent" rows="5" placeholder="공지사항을 입력하세요..." style="width: 100%; padding: 15px; border: 2px solid #e1e5e9; border-radius: 10px; font-size: 16px; resize: vertical; min-height: 120px;"></textarea>
        </div>

        <div class="important-notice-checkbox">
            <input type="checkbox" id="isImportantNotice">
            <label for="isImportantNotice">중요 공지 (로그인 시 자동 표시)</label>
        </div>

        <div style="text-align: right; margin-bottom: 20px; color: #999; font-size: 14px;">
            글자수: <span id="noticeCharCount">0</span>/3000
        </div>

        <div class="admin-action-buttons">
            <button type="button" class="btn success small" onclick="saveNotice()">공지 저장</button>
            <button type="button" class="btn danger small" onclick="deleteNotice()">공지 삭제</button>
            <button type="button" class="btn secondary small" onclick="cancelNoticeEdit()">취소</button>
        </div>
    </div>
</div>
<!-- 공지사항 확인 모달 -->
<div id="noticeViewModal" class="modal">
    <div class="modal-content notice-modal-content">
        <span class="close" onclick="closeNoticeViewModal()">&times;</span>
        <h2 id="noticeViewTitle">📢 공지사항</h2>
        
        <div id="noticeViewContent" style="margin: 20px 0; line-height: 1.6; font-size: var(--base-font-size);">
            <!-- 공지 내용이 여기에 표시됩니다 -->
        </div>
        
        <div id="noticeViewDate" class="notice-date">
            <!-- 등록 날짜가 여기에 표시됩니다 -->
        </div>

        <div style="text-align: center; margin-top: 30px;">
            <button type="button" class="btn" onclick="closeNoticeViewModal()">확인</button>
        </div>
    </div>
</div>

    <script>// 신청자 데이터를 저장할 객체
        const applicants = {};
        const days = ['월요일', '화요일', '수요일', '목요일', '금요일', '토요일', '일요일'];
        const KMA_API_KEY = "9a51af0f896d3b36123dd1e23780795957e9349038e8410404b6260b68309a7e";
        const SEOUL_LAT = 37.5665;
        const SEOUL_LON = 126.9780;
        const GAS_URL = "https://script.google.com/macros/s/AKfycbzpcLIHHRPMtxkSTAa_3VzDl5ss5IWsGOp_UlCU5iZi6P0rw7WBXiNezbZhb_pprhV5Pw/exec";
        let currentChatRoom = null;
        let messengerApp, messengerDb;
        let messagesUnsubscribe = null;
        let memos = [];
        let currentMemoZone = '';
        let zones = []; // 동적으로 로드
        let timeSlots = []; // 시간대 배열
        let currentUser = '';
        let isAdmin = false;
        let userApplications = [];
        let allApplications = [];
        let monthlyData = [];
        let currentStatsYear = new Date().getFullYear();
        let currentStatsMonth = new Date().getMonth() + 1;
        let allowedUsers = []; // 서버에서 로드될 배열
        let usersLoaded = false; // 사용자 데이터 로드 여부 확인
        // 공지사항 관련 변수
        let currentNotice = null;
        let originalNoticeContent = '';
        let currentChart = null;
        let currentView = 'table';
        let currentStatsType = 'zone';

        // 초기 데이터 구조 생성
function initializeApplicants() {
    // applicants 객체 초기화
    days.forEach(day => {
        applicants[day] = {};
    });
    
    // zones 데이터로 applicants 구조 채우기
    zones.forEach(zone => {
        days.forEach(day => {
            applicants[day][zone.name] = {};
            
            // 해당 요일에 활성화된 시간대 찾기
            if (zone.schedules) {
                zone.schedules.forEach(schedule => {
                    if (schedule.days && schedule.days.includes(day)) {
                        schedule.timeSlots.forEach(timeSlot => {
                            if (timeSlot.isActive !== false) {
                                applicants[day][zone.name][timeSlot.time] = [];
                            }
                        });
                    }
                });
            }
        });
    });
    
    console.log('Initialized applicants structure:', applicants);
}

        // 페이지 로드 시 초기화
        window.initializeApp = async function () {
    try {
        console.log('Initializing application...');
        setCurrentWeekDates();
        setAdminWeekDates();
        
        // 사용자와 구역을 병렬로 로드
        await Promise.all([
            loadZonesFromFirestore(),
            loadUsersFromFirestore()
        ]);
        
        populateAdminUserSelect();
        loadDataFromFirestore();
        loadNoticeFromFirestore();

        document.getElementById('loginName').addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                login();
            }
        });
        
        console.log('Application initialized successfully');
    } catch (error) {
        console.error('앱 초기화 오류:', error);
        alert('애플리케이션 초기화 중 오류가 발생했습니다.');
    }
};

        // Firestore에서 구역 목록 로드
        // Firestore에서 구역 목록 로드 함수 수정
        async function loadZonesFromFirestore() {
    try {
        const { collection, getDocs } = window.firestoreFunctions;
        const zonesRef = collection(window.db, 'zones');
        const querySnapshot = await getDocs(zonesRef);
        zones = [];
        
        querySnapshot.forEach((doc) => {
            const data = doc.data();
            console.log('Zone data from Firestore:', data); // 디버깅용 로그
            
            // 기존 데이터와의 호환성을 위한 처리
            let schedules = data.schedules;
            
            // 기존 timeSlots 구조를 새로운 schedules 구조로 변환
            if (!schedules && data.timeSlots) {
                schedules = [{
                    days: data.days || ['월요일', '화요일', '수요일', '목요일', '금요일', '토요일', '일요일'],
                    timeSlots: data.timeSlots.map(slot => ({
                        time: slot.time,
                        maxCapacity: slot.maxCapacity || 4,
                        isActive: slot.isActive !== false // 기본값 true
                    }))
                }];
            }
            
            // schedules가 없는 경우 기본값 설정
            if (!schedules) {
                schedules = [{
                    days: ['월요일', '화요일', '수요일', '목요일', '금요일', '토요일', '일요일'],
                    timeSlots: [
                        {time: "09:00-12:00", maxCapacity: 4, isActive: true},
                        {time: "13:00-16:00", maxCapacity: 4, isActive: true}
                    ]
                }];
            }
            
            zones.push({
                id: doc.id,
                name: data.name,
                schedules: schedules
            });
        });
        
        console.log('Processed zones:', zones);
        initializeApplicants();
        updateZoneUI();
        updateDaySelectionModal();
        updateDisplay();
        createDayTabs();
        populateZoneOptions();
    } catch (error) {
        console.error('구역 로드 오류:', error);
        alert('구역 목록을 불러오는 중 오류가 발생했습니다: ' + error.message);
    }
}
// Firebase 모듈 동적 로딩 및 초기화
async function initializeMessengerFirebase() {
    if (messengerDb) return messengerDb;
    
    try {
        const { initializeApp } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-app.js');
        const { getFirestore, collection, addDoc, query, where, orderBy, onSnapshot, serverTimestamp } = await import('https://www.gstatic.com/firebasejs/10.7.0/firebase-firestore.js');
        
        messengerApp = initializeApp(window.messengerFirebaseConfig, 'messenger');
        messengerDb = getFirestore(messengerApp);
        
        // 전역에서 사용할 수 있도록 저장
        window.messengerFirestore = {
            db: messengerDb,
            collection,
            addDoc,
            query,
            where,
            orderBy,
            onSnapshot,
            serverTimestamp
        };
        
        console.log('메신저 Firebase 초기화 완료');
        return messengerDb;
    } catch (error) {
        console.error('메신저 Firebase 초기화 오류:', error);
        throw error;
    }
}
       // 구역 UI 동적 업데이트 (모달 등)
       function updateZoneUI() {
    const zoneSelection = document.getElementById('zoneSelection');
    if (zoneSelection) {
        zoneSelection.innerHTML = '';
        zones.forEach((zone, index) => {
            const optionDiv = document.createElement('div');
            optionDiv.className = 'zone-option';
            
            // 총 용량 계산 (모든 스케줄의 모든 시간대 용량 합계)
            let totalCapacity = 0;
            if (zone.schedules) {
                zone.schedules.forEach(schedule => {
                    if (schedule.timeSlots) {
                        schedule.timeSlots.forEach(slot => {
                            if (slot.isActive !== false) {
                                totalCapacity += slot.maxCapacity || 4;
                            }
                        });
                    }
                });
            }
            
            const currentTotal = getCurrentZoneTotal(zone.name);
            
            optionDiv.innerHTML = `
                <input type="radio" id="zone${index}" name="zone" value="${zone.name}">
                <label for="zone${index}" class="zone-label" data-zone="${zone.name}">
                    ${zone.name}
                </label>
            `;
            zoneSelection.appendChild(optionDiv);
        });
    }

    const adminZoneSelection = document.getElementById('adminZoneSelection');
    if (adminZoneSelection) {
        adminZoneSelection.innerHTML = '';
        zones.forEach((zone, index) => {
            const optionDiv = document.createElement('div');
            optionDiv.className = 'zone-option';
            
            // 총 용량 계산
            let totalCapacity = 0;
            if (zone.schedules) {
                zone.schedules.forEach(schedule => {
                    if (schedule.timeSlots) {
                        schedule.timeSlots.forEach(slot => {
                            if (slot.isActive !== false) {
                                totalCapacity += slot.maxCapacity || 4;
                            }
                        });
                    }
                });
            }
            
            optionDiv.innerHTML = `
                <input type="radio" id="admin-zone${index}" name="admin-zone" value="${zone.name}">
                <label for="admin-zone${index}" class="zone-label" data-zone="${zone.name}">
                    ${zone.name}
                    <div class="capacity-info">0/${totalCapacity}</div>
                </label>
            `;
            adminZoneSelection.appendChild(optionDiv);
        });
    }
    console.log('Zone UI updated');
}
      
// 메모 모달 열기
function openMemoModal() {
    const modal = document.getElementById('memoModal');
    if (!modal) {
        console.error('Memo modal not found');
        return;
    }
    
    modal.style.display = 'block';
    
    // 새 메모 추가 버튼 요소 찾기
    const addButton = modal.querySelector('button');
    
    // 비로그인 상태면 버튼 숨기기, 로그인 상태면 보이기
    if (!currentUser) {
        if (addButton) addButton.style.display = 'none';
    } else {
        if (addButton) addButton.style.display = 'block';
    }
    
    // 메모 데이터 로드
    loadMemos();
}
// 메모 모달 닫기
function closeMemoModal() {
    document.getElementById('memoModal').style.display = 'none';
}

// 메모 작성/수정 모달 열기
function openEditMemoModal(memoId = null) {
    if (!currentUser) {
        alert('로그인이 필요합니다.');
        return;
    }
    
    const modal = document.getElementById('editMemoModal');
    const title = document.getElementById('editMemoTitle');
    const deleteBtn = document.getElementById('deleteMemoBtn');
    
    // 구역 옵션이 채워졌는지 확인하고 없으면 채우기
    if (document.getElementById('memoZone').options.length === 0) {
        populateZoneOptions();
    }
    
    if (memoId) {
        // 수정 모드
        title.textContent = "메모 수정";
        deleteBtn.style.display = 'block';
        
        const memo = memos.find(m => m.id === memoId);
        if (memo) {
            document.getElementById('memoId').value = memoId;
            document.getElementById('memoZone').value = memo.zone;
            document.getElementById('memoContentInput').value = memo.content;
        }
    } else {
        // 새 메모 모드
        title.textContent = "새 메모 작성";
        deleteBtn.style.display = 'none';
        document.getElementById('memoId').value = '';
        document.getElementById('memoZone').selectedIndex = 0;
        document.getElementById('memoContentInput').value = '';
    }
    
    modal.style.display = 'block';
}
// 메모 작성/수정 모달 닫기
function closeEditMemoModal() {
    document.getElementById('editMemoModal').style.display = 'none';
}

// 구역 선택 옵션 채우기
function populateZoneOptions() {
    const select = document.getElementById('memoZone');
    select.innerHTML = '';
    
    // 기본 옵션 추가
    const defaultOption = document.createElement('option');
    defaultOption.value = "";
    defaultOption.textContent = "구역을 선택하세요";
    defaultOption.disabled = true;
    defaultOption.selected = true;
    select.appendChild(defaultOption);
    
    // 구역 옵션 추가
    zones.forEach(zone => {
        const option = document.createElement('option');
        option.value = zone.name;
        option.textContent = zone.name;
        select.appendChild(option);
    });
}
// 메모 불러오기
async function loadMemos() {
    try {
        console.log('Loading memos from:', GAS_URL);
        const response = await fetch(`${GAS_URL}?action=getMemos`);
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const text = await response.text();
        console.log('Raw response:', text);
        
        // 빈 응답 체크
        if (!text.trim()) {
            memos = [];
            console.log('No memos found (empty response)');
        } else {
            memos = JSON.parse(text);
            console.log('Loaded memos:', memos);
        }
        
        createMemoTabs();
        displayMemos();
    } catch (error) {
        console.error('메모 로드 오류:', error);
        alert('메모를 불러오는 중 오류가 발생했습니다. 메모 저장용 서버가 불안정해 원래 오류가 자주 발생하니 조금 시간을 두고 다시 시도해주세요. error_code: ' + error.message);
    }
}
// 메모 탭 생성
function createMemoTabs() {
    const tabsContainer = document.getElementById('memoTabs');
    if (!tabsContainer) {
        console.error('Memo tabs container not found');
        return;
    }
    
    tabsContainer.innerHTML = '';
    
    // 모든 구역에 대한 탭 생성 (메모가 없어도)
    zones.forEach(zone => {
        const tab = document.createElement('div');
        tab.className = 'memo-tab';
        tab.textContent = zone.name;
        tab.dataset.zone = zone.name;
        
        tab.addEventListener('click', () => {
            document.querySelectorAll('.memo-tab').forEach(t => t.classList.remove('active'));
            tab.classList.add('active');
            currentMemoZone = zone.name;
            displayMemos();
        });
        
        tabsContainer.appendChild(tab);
    });
    
    // 첫 번째 탭 활성화
    const firstTab = tabsContainer.querySelector('.memo-tab');
    if (firstTab) {
        firstTab.classList.add('active');
        currentMemoZone = firstTab.dataset.zone;
    } else if (zones.length > 0) {
        // zones는 있지만 탭이 생성되지 않은 경우
        currentMemoZone = zones[0].name;
    }
}

// 메모 표시 (수정된 버전)
function displayMemos() {
    const contentContainer = document.getElementById('memoContent');
    if (!contentContainer) {
        console.error('Memo content container not found');
        return;
    }
    
    contentContainer.innerHTML = '';
    
    if (!memos || memos.length === 0) {
        contentContainer.innerHTML = '<div class="no-memos">등록된 메모가 없습니다.</div>';
        return;
    }
    
    // 👇 *** 이 부분을 수정하세요! *** 👇
    // memo.zone을 문자열(String)으로 변환하여 currentMemoZone과 비교합니다.
    const zoneMemos = memos.filter(memo => String(memo.zone) === currentMemoZone);
    
    if (zoneMemos.length === 0) {
        contentContainer.innerHTML = '<div class="no-memos">이 구역에 등록된 메모가 없습니다.</div>';
        return;
    }
    
    // 최신 메모가 위로 오도록 정렬
    zoneMemos.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
    
    zoneMemos.forEach(memo => {
        const memoElement = document.createElement('div');
        memoElement.className = 'memo-item';
        
        const canEdit = currentUser && (isAdmin || memo.author === currentUser);
        
        memoElement.innerHTML = `
            <div class="memo-content-text">${memo.content}</div>
            <div class="memo-meta">
                <span>${memo.author}</span>
                <span>${formatDate(memo.createdAt)}</span>
            </div>
            ${canEdit ? `
                <div class="memo-actions">
                    <button class="btn small" onclick="openEditMemoModal('${memo.id}')">수정</button>
                </div>
            ` : ''}
        `;
        
        contentContainer.appendChild(memoElement);
    });
}// 날짜 형식화
function formatDate(dateString) {
    const date = new Date(dateString);
    return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
}

// 메모 저장
async function saveMemo(e) {
    e.preventDefault();
    
    const memoId = document.getElementById('memoId').value;
    const zone = document.getElementById('memoZone').value;
    const content = document.getElementById('memoContentInput').value;
    
    if (!zone || zone === "") {
        alert('구역을 선택해주세요.');
        return;
    }
    
    if (!content || content.trim() === "") {
        alert('메모 내용을 입력해주세요.');
        return;
    }
    
    try {
        const formData = new FormData();
        formData.append('action', memoId ? 'updateMemo' : 'createMemo');
        if (memoId) formData.append('id', memoId);
        formData.append('zone', zone);
        formData.append('content', content.trim());
        formData.append('author', currentUser);
        
        const response = await fetch(GAS_URL, {
            method: 'POST',
            body: formData
        });
        
        if (response.ok) {
            alert('메모가 저장되었습니다.');
            closeEditMemoModal();
            loadMemos();
        } else {
            throw new Error('메모 저장 실패');
        }
    } catch (error) {
        console.error('메모 저장 오류:', error);
        alert('메모 저장 중 오류가 발생했습니다.');
    }
}
// 메모 삭제
async function deleteMemo() {
    const memoId = document.getElementById('memoId').value;
    
    if (!confirm('정말 이 메모를 삭제하시겠습니까?')) {
        return;
    }
    
    try {
        const formData = new FormData();
        formData.append('action', 'deleteMemo');
        formData.append('id', memoId);
        
        const response = await fetch(GAS_URL, {
            method: 'POST',
            body: formData
        });
        
        if (response.ok) {
            alert('메모가 삭제되었습니다.');
            closeEditMemoModal();
            loadMemos();
        } else {
            throw new Error('메모 삭제 실패');
        }
    } catch (error) {
        console.error('메모 삭제 오류:', error);
        alert('메모 삭제 중 오류가 발생했습니다.');
    }
}

// 이벤트 리스너 등록
document.addEventListener('DOMContentLoaded', function() {
    applySavedFontSize();
    
    // 메모 폼 이벤트 리스너
    document.getElementById('editMemoForm').addEventListener('submit', saveMemo);
    
    // 구역 데이터가 로드된 후 옵션 채우기
    if (typeof zones !== 'undefined' && zones.length > 0) {
        populateZoneOptions();
    }
});
function getCurrentZoneTotal(zoneName) {
    const selectedDay = document.querySelector('input[name="day"]:checked')?.value;
    if (!selectedDay || !applicants[selectedDay] || !applicants[selectedDay][zoneName]) {
        return 0;
    }
    
    let total = 0;
    Object.keys(applicants[selectedDay][zoneName]).forEach(timeSlot => {
        total += (applicants[selectedDay][zoneName][timeSlot] || []).length;
    });
    return total;
}
function openStatsModal() {
    const statsModal = document.getElementById('statsModal');
    if (!statsModal) {
        console.error('statsModal 요소를 찾을 수 없습니다.');
        return;
    }
    statsModal.style.display = 'block';
    window.currentStatsYear = new Date().getFullYear();
    window.currentStatsMonth = new Date().getMonth() + 1;
    loadMonthlyStats();
}

function closeStatsModal() {
    const statsModal = document.getElementById('statsModal');
    if (statsModal) {
        statsModal.style.display = 'none';
    }
}
// 시간 선택 UI 업데이트
// 시간 선택 UI 업데이트 함수 수정
function updateTimeSelection(selectedDay, selectedZone) {
    const timeSelection = document.getElementById('timeSelection');
    const timeContainer = document.getElementById('timeSelectionContainer');
    const zoneObj = zones.find(z => z.name === selectedZone);
    
    if (!zoneObj || !zoneObj.schedules) {
        timeContainer.classList.remove('show');
        timeSelection.innerHTML = '<div class="empty-time-slots">구역 정보를 찾을 수 없습니다.</div>';
        return;
    }
    
    timeSelection.innerHTML = '';
    let hasActiveSlots = false;
    
    // 선택된 요일에 해당하는 시간대 찾기
    zoneObj.schedules.forEach(schedule => {
        if (schedule.days && schedule.days.includes(selectedDay)) {
            schedule.timeSlots.forEach((timeSlot, index) => {
                if (timeSlot.isActive !== false) {
                    hasActiveSlots = true;
                    
                    const currentCount = applicants[selectedDay] && 
                                         applicants[selectedDay][selectedZone] && 
                                         applicants[selectedDay][selectedZone][timeSlot.time] 
                                         ? applicants[selectedDay][selectedZone][timeSlot.time].length 
                                         : 0;
                    
                    const isDisabled = currentCount >= (timeSlot.maxCapacity || 4);
                    
                    const optionDiv = document.createElement('div');
                    optionDiv.className = 'time-option';
                    
                    const radioInput = document.createElement('input');
                    radioInput.type = 'radio';
                    radioInput.id = `time${index}`;
                    radioInput.name = 'time';
                    radioInput.value = timeSlot.time;
                    radioInput.disabled = isDisabled;
                    
                    const label = document.createElement('label');
                    label.htmlFor = `time${index}`;
                    label.className = `time-label ${isDisabled ? 'disabled' : ''}`;
                    label.dataset.time = timeSlot.time;
                    
                    // 겹침 확인
                    let isOverlappingTime = false;
                    if (userApplications && userApplications.length > 0) {
                        userApplications.forEach(app => {
                            if (app.day === selectedDay && isOverlapping(timeSlot.time, app.timeSlot)) {
                                isOverlappingTime = true;
                            }
                        });
                    }
                    
                    if (isOverlappingTime) {
                        radioInput.disabled = true;
                        label.classList.add('disabled');
                    }
                    
                    label.innerHTML = `
                        ${formatTimeToAMPM(timeSlot.time)}
                        <div class="time-capacity-info">${currentCount}/${timeSlot.maxCapacity || 4}</div>
                        ${isOverlappingTime ? '<div class="warning">이미 신청된 시간대입니다</div>' : ''}
                    `;
                    
                    optionDiv.appendChild(radioInput);
                    optionDiv.appendChild(label);
                    timeSelection.appendChild(optionDiv);
                }
            });
        }
    });
    
    if (hasActiveSlots) {
        timeContainer.classList.add('show');
    } else {
        timeContainer.classList.remove('show');
        timeSelection.innerHTML = '<div class="empty-time-slots">사용 가능한 시간대가 없습니다.</div>';
    }
}
// 시간대 추가 함수
function addTimeSlot() {
    const container = document.getElementById('timeSlotSettings');
    const index = container.children.length;
    
    const timeSlotDiv = document.createElement('div');
    timeSlotDiv.className = 'time-slot-setting';
    timeSlotDiv.innerHTML = `
        <div class="time-slot-row">
            <div class="time-input-group">
                <label class="time-input-label">시작 시간</label>
                <div class="time-picker-container">
                    <div class="time-picker">
                        <select class="time-select start-hour">
                            ${generateHourOptions()}
                        </select>
                        <span>:</span>
                        <select class="time-select start-minute">
                            ${generateMinuteOptions()}
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="time-input-group">
                <label class="time-input-label">종료 시간</label>
                <div class="time-picker-container">
                    <div class="time-picker">
                        <select class="time-select end-hour">
                            ${generateHourOptions()}
                        </select>
                        <span>:</span>
                        <select class="time-select end-minute">
                            ${generateMinuteOptions()}
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="time-input-group">
                <label class="time-input-label">최대 인원</label>
                <input type="number" class="capacity-input" value="4" min="1" max="20">
            </div>
            
            <div class="time-input-group">
                <button type="button" class="btn remove-time" onclick="removeTimeSlot(this)">삭제</button>
            </div>
        </div>
    `;
    
    container.appendChild(timeSlotDiv);
    
    // 기본값 설정
    const startHour = timeSlotDiv.querySelector('.start-hour');
    const endHour = timeSlotDiv.querySelector('.end-hour');
    if (index === 0) {
        startHour.value = '09';
        endHour.value = '12';
    } else {
        startHour.value = '13';
        endHour.value = '16';
    }
}

// 시간대 삭제 함수
function removeTimeSlot(button) {
    button.closest('.time-slot-setting').remove();
}

// 글자 크기 슬라이더 토글
function toggleFontSizeSlider() {
    const slider = document.getElementById('fontSizeSlider');
    const isShowing = slider.classList.contains('show');
    
    if (isShowing) {
        closeFontSizeSlider();
    } else {
        openFontSizeSlider();
    }
}

// 글자 크기 슬라이더 열기
function openFontSizeSlider() {
    const slider = document.getElementById('fontSizeSlider');
    slider.classList.add('show');
    
    // 저장된 글자 크기 값으로 슬라이더 초기화
    const savedSize = localStorage.getItem('fontSize');
    if (savedSize) {
        const fontSize = parseInt(savedSize.replace('px', ''));
        document.getElementById('fontSizeRange').value = fontSize;
        document.getElementById('fontSizeValue').textContent = savedSize;
    }
    
    // 슬라이더에 포커스
    document.getElementById('fontSizeRange').focus();
}

// 글자 크기 슬라이더 닫기
function closeFontSizeSlider() {
    const slider = document.getElementById('fontSizeSlider');
    slider.classList.remove('show');
}

// 글자 크기 변경 처리
function changeFontSize(baseSize) {
  // 기본 크기 비율 계산
  const ratio = baseSize / 16;
  
  // CSS 변수 업데이트
  document.documentElement.style.setProperty('--base-font-size', `${baseSize}px`);
  document.documentElement.style.setProperty('--heading-font-size', `${26 * ratio}px`);
  document.documentElement.style.setProperty('--button-font-size', `${17 * ratio}px`);
  document.documentElement.style.setProperty('--label-font-size', `${15 * ratio}px`);
  document.documentElement.style.setProperty('--small-font-size', `${13 * ratio}px`);
  
  // 변경된 값 표시
  document.getElementById('fontSizeValue').textContent = baseSize + 'px';
  
  // 로컬 스토리지에 저장
  localStorage.setItem('fontSize', baseSize + 'px');
}

// 페이지 로드 시 저장된 글자 크기 적용
function applySavedFontSize() {
  const savedSize = localStorage.getItem('fontSize');
  if (savedSize) {
    const sizeValue = parseInt(savedSize.replace('px', ''));
    changeFontSize(sizeValue);
    
    // 슬라이더 값도 업데이트
    const slider = document.getElementById('fontSizeRange');
    if (slider) {
      slider.value = sizeValue;
    }
  }
}
// 요일 탭 생성 함수
function createDayTabs() {
    const dayTabsContainer = document.getElementById('dayTabs');
    dayTabsContainer.innerHTML = '';
    
    // 오늘 날짜의 요일 찾기
    const today = new Date();
    const dayNames = ['일요일', '월요일', '화요일', '수요일', '목요일', '금요일', '토요일'];
    const todayDayName = dayNames[today.getDay()];
    let activeDay = todayDayName;
    
    days.forEach(day => {
        // 해당 요일에 활성화된 구역이 있는지 확인
        const hasActiveZones = zones.some(zone => {
            if (!zone.schedules) return false;
            return zone.schedules.some(schedule => 
                schedule.days && schedule.days.includes(day)
            );
        });
        
        // 활성화된 구역이 없으면 탭을 생성하지 않음
        if (!hasActiveZones) return;
        
        const tab = document.createElement('div');
        tab.className = `day-tab ${day === activeDay ? 'active' : ''}`;
        tab.textContent = day;
        tab.dataset.day = day;
        
        tab.addEventListener('click', () => {
            // 모든 탭에서 active 클래스 제거
            document.querySelectorAll('.day-tab').forEach(t => t.classList.remove('active'));
            // 클릭한 탭에 active 클래스 추가
            tab.classList.add('active');
            // 해당 요일의 신청현황 표시
            displayDayApplications(day);
        });
        
        dayTabsContainer.appendChild(tab);
    });
    
    // 활성 탭이 있으면 해당 요일 표시
    const activeTab = document.querySelector('.day-tab.active');
    if (activeTab) {
        displayDayApplications(activeTab.dataset.day);
    }
    scrollToActiveTab()
}

// 특정 요일의 신청현황 표시 함수
function displayDayApplications(day) {
    const applicantsListEl = document.getElementById('applicantsList');
    applicantsListEl.innerHTML = '';
    
    // 해당 요일에 활성화된 구역이 있는지 확인
    const hasActiveZones = zones.some(zone => {
        if (!zone.schedules) return false;
        return zone.schedules.some(schedule => 
            schedule.days && schedule.days.includes(day)
        );
    });
    
    if (!hasActiveZones) {
        applicantsListEl.innerHTML = '<div class="no-applications">해당 요일은 등록된 구역이 없습니다.</div>';
        return;
    }
    
    const dayDiv = document.createElement('div');
    dayDiv.className = 'day-section';

    const dayTitleDiv = document.createElement('div');
    dayTitleDiv.className = 'day-title';
    const dayDate = getDateForDay(day);
    dayTitleDiv.textContent = `${day} (${dayDate})`;
    dayDiv.appendChild(dayTitleDiv);

    zones.forEach(zone => {
        // 해당 요일에 구역이 활성화되어 있는지 확인
        let hasActiveSlots = false;
        if (zone.schedules) {
            zone.schedules.forEach(schedule => {
                if (schedule.days && schedule.days.includes(day)) {
                    hasActiveSlots = true;
                }
            });
        }
        
        if (!hasActiveSlots) return;

        const zoneDiv = document.createElement('div');
        zoneDiv.className = 'zone-applicants';

        const zoneNameDiv = document.createElement('div');
        zoneNameDiv.className = 'zone-name';
        zoneNameDiv.textContent = zone.name;

        const timeSlotsDiv = document.createElement('div');
        timeSlotsDiv.className = 'time-slots-container';
        
        // 해당 요일에 활성화된 시간대 표시
        if (zone.schedules) {
            zone.schedules.forEach(schedule => {
                if (schedule.days && schedule.days.includes(day)) {
                    schedule.timeSlots.forEach(slot => {
                        if (slot.isActive !== false) {
                            const currentCount = applicants[day] && 
                                                 applicants[day][zone.name] && 
                                                 applicants[day][zone.name][slot.time] 
                                                 ? applicants[day][zone.name][slot.time].length 
                                                 : 0;
                            
                            const timeSlotDiv = document.createElement('div');
timeSlotDiv.className = 'time-slot-item';
timeSlotDiv.style.marginBottom = '12px';
const timeHeaderDiv = document.createElement('div');
timeHeaderDiv.className = 'time-slot-header';
timeHeaderDiv.style.color = '#667eea';
timeHeaderDiv.style.fontWeight = '700';
timeHeaderDiv.style.marginBottom = '6px';

// 시간대 헤더에 채팅 버튼 추가
timeHeaderDiv.innerHTML = `
    ${formatTimeToAMPM(slot.time)} (${currentCount}/${slot.maxCapacity || 4})
    <button class="btn small" onclick="openMessengerModal('${day}', '${zone.name}', '${slot.time}')" style="margin-left: 10px; padding: 4px 8px; font-size: 12px;">
        💬
    </button>
`;
                            
                            const namesDiv = document.createElement('div');
                            if (currentCount > 0) {
                                namesDiv.innerHTML = applicants[day][zone.name][slot.time]
                                    .map(name => `<span class="name-tag">${name}</span>`)
                                    .join('');
                            } else {
                                namesDiv.innerHTML = '<span style="color: #a0aec0; font-style: italic;">신청자 없음</span>';
                            }
                            
                            timeSlotDiv.appendChild(timeHeaderDiv);
                            timeSlotDiv.appendChild(namesDiv);
                            timeSlotsDiv.appendChild(timeSlotDiv);
                        }
                    });
                }
            });
        }

        zoneDiv.appendChild(zoneNameDiv);
        zoneDiv.appendChild(timeSlotsDiv);
        dayDiv.appendChild(zoneDiv);
    });

    applicantsListEl.appendChild(dayDiv);
}

// DOM이 로드된 후 실행
window.addEventListener('DOMContentLoaded', function() {
    // 저장된 글자 크기 적용
    applySavedFontSize();
    
    // 슬라이더 이벤트 리스너 추가
// 기존 코드에서 이 부분을 찾아 수정합니다
const fontSizeSlider = document.getElementById('fontSizeRange');
if (fontSizeSlider) {
  fontSizeSlider.addEventListener('input', function() {
    changeFontSize(parseInt(this.value));
  });
}
    
    // 외부 클릭 시 슬라이더 닫기
    document.addEventListener('click', function(event) {
        const slider = document.getElementById('fontSizeSlider');
        const fontBtn = document.querySelector('.font-size-btn');
        
        if (slider.classList.contains('show') && 
            !slider.contains(event.target) && 
            !fontBtn.contains(event.target)) {
            closeFontSizeSlider();
        }
    });
    
    // ESC 키로 슬라이더 닫기
    document.addEventListener('keydown', function(event) {
        if (event.key === 'Escape') {
            const slider = document.getElementById('fontSizeSlider');
            if (slider.classList.contains('show')) {
                closeFontSizeSlider();
            }
        }
    });
});

// 다크모드에서의 글자 크기 버튼 색상 업데이트
function updateFontSizeButtonColor() {
    const fontSizeBtn = document.querySelector('.font-size-btn');
    if (document.body.classList.contains('dark-mode')) {
        fontSizeBtn.style.background = 'rgba(45, 55, 72, 0.95)';
        fontSizeBtn.style.color = '#9f7aea';
    } else {
        fontSizeBtn.style.background = 'rgba(255, 255, 255, 0.95)';
        fontSizeBtn.style.color = '#667eea';
    }
}


function updateAdminTimeSelection(selectedDay, selectedZone) {
    const timeSelection = document.getElementById('adminTimeSelection');
    const zoneObj = zones.find(z => z.name === selectedZone);
    
    if (!zoneObj) return;
    
    timeSelection.innerHTML = '';
    
    zoneObj.timeSlots.forEach((timeSlot, index) => {
        if (!timeSlot.isActive) return;
        
        const currentCount = applicants[selectedDay][selectedZone][timeSlot.time]?.length || 0;
        
        const optionDiv = document.createElement('div');
        optionDiv.className = 'time-option';
        
        const radioInput = document.createElement('input');
        radioInput.type = 'radio';
        radioInput.id = `admin-time${index}`;
        radioInput.name = 'admin-time';
        radioInput.value = timeSlot.time;
        
        const label = document.createElement('label');
        label.htmlFor = `admin-time${index}`;
        label.className = 'time-label';
        label.dataset.time = timeSlot.time;
        
        label.innerHTML = `
            ${formatTimeToAMPM(timeSlot.time)}
            <div class="time-capacity-info">${currentCount}/${timeSlot.maxCapacity}</div>
        `;
        
        optionDiv.appendChild(radioInput);
        optionDiv.appendChild(label);
        timeSelection.appendChild(optionDiv);
    });
}
// 메신저 모달 열기 함수
async function openMessengerModal(day, zone, timeSlot) {
    console.log('메신저 모달 열기 시작:', day, zone, timeSlot);
    
    try {
        // Firebase 초기화 확인
        await initializeMessengerFirebase();
        console.log('메신저 Firebase 초기화 완료');
        
        // 현재 사용자가 이 시간대에 신청했는지 확인
        const hasApplied = userApplications.some(app => 
            app.day === day && app.zone === zone && app.timeSlot === timeSlot
        );
        
        if (!hasApplied && !isAdmin) {
            alert('이 시간대에 신청한 사람만 채팅에 참여할 수 있습니다.');
            return;
        }
        
        currentChatRoom = { day, zone, timeSlot };
        document.getElementById('messengerInfo').textContent = `${day} ${zone} ${formatTimeToAMPM(timeSlot)} 채팅방`;
        
        // body에 modal-open 클래스 추가하여 배경 스크롤 방지
        document.body.classList.add('modal-open');
        
        document.getElementById('messengerModal').style.display = 'block';
        const modalContent = document.querySelector('#messengerModal .modal-content');
        modalContent.style.animation = 'modalFadeIn 0.3s ease';
        document.getElementById('messageInput').value = '';
        
        // 실시간 메시지 리스너 시작
        startMessageListener();
        console.log('메시지 리스너 시작됨');
        
    } catch (error) {
        console.error('메신저 모달 열기 오류:', error);
        alert('채팅방을 여는 중 오류가 발생했습니다: ' + error.message);
    }
}
// 메신저 모달 닫기 함수
function closeMessengerModal() {
    document.getElementById('messengerModal').style.display = 'none';
    
    // body에서 modal-open 클래스 제거하여 배경 스크롤 복원
    document.body.classList.remove('modal-open');
    
    // 실시간 리스너 정리
    if (messagesUnsubscribe) {
        messagesUnsubscribe();
        messagesUnsubscribe = null;
    }
    
    currentChatRoom = null;
}
// 시간 형식화 함수 추가 (24시간제 -> 오전/오후 변환)
function formatTime(date) {
    const hours = date.getHours();
    const minutes = date.getMinutes().toString().padStart(2, '0');
    
    if (hours === 0) {
        return `오전 12:${minutes}`;
    } else if (hours < 12) {
        return `오전 ${hours}:${minutes}`;
    } else if (hours === 12) {
        return `오후 12:${minutes}`;
    } else {
        return `오후 ${hours - 12}:${minutes}`;
    }
}
// 실시간 메시지 리스너 시작
function startMessageListener() {
    if (!currentChatRoom || !window.messengerFirestore) return;
    
    // 기존 리스너가 있다면 정리
    if (messagesUnsubscribe) {
        messagesUnsubscribe();
        messagesUnsubscribe = null;
    }
    
    const { db, collection, query, where, orderBy, onSnapshot } = window.messengerFirestore;
    
    // 채팅방 ID 생성 (day_zone_timeSlot 형식)
    const chatRoomId = `${currentChatRoom.day}_${currentChatRoom.zone}_${currentChatRoom.timeSlot}`.replace(/\s+/g, '_');
    
    // 실시간 쿼리 설정
    const messagesQuery = query(
        collection(db, 'chatMessages'),
        where('chatRoomId', '==', chatRoomId),
        orderBy('timestamp', 'asc')
    );
    
    // 실시간 리스너 등록
    messagesUnsubscribe = onSnapshot(messagesQuery, 
        (snapshot) => {
            const messages = [];
            snapshot.forEach((doc) => {
                const data = doc.data();
                messages.push({
                    id: doc.id,
                    author: data.author,
                    content: data.content,
                    timestamp: data.timestamp?.toDate() || new Date()
                });
            });
            
            displayMessages(messages);
        }, 
        (error) => {
            console.error('메시지 리스너 오류:', error);
            // 인덱스 에러는 무시 (임시 처리)
            if (error.code !== 'failed-precondition') {
                alert('메시지 로딩 중 오류가 발생했습니다.');
            }
        }
    );
}

// 메시지 표시 함수
function displayMessages(messages) {
    const container = document.getElementById('messagesContainer');
    container.innerHTML = '';
    
    if (messages.length === 0) {
        container.innerHTML = '<div style="text-align: center; color: #999; padding: 20px;">아직 메시지가 없습니다.</div>';
        return;
    }
    
    messages.forEach(msg => {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${msg.author === currentUser ? 'my-message' : 'other-message'}`;
        
        const contentDiv = document.createElement('div');
        contentDiv.textContent = msg.content;
        
        const infoDiv = document.createElement('div');
        infoDiv.className = 'message-info';
        
        const authorSpan = document.createElement('span');
        authorSpan.textContent = msg.author;
        
        const timeSpan = document.createElement('span');
        timeSpan.textContent = formatTime(msg.timestamp);
        
        infoDiv.appendChild(authorSpan);
        infoDiv.appendChild(timeSpan);
        
        messageDiv.appendChild(contentDiv);
        messageDiv.appendChild(infoDiv);
        
        container.appendChild(messageDiv);
    });
    
    // 스크롤을 최신 메시지로 이동
    container.scrollTop = container.scrollHeight;
}
window.onclick = function(event) {
    const messengerModal = document.getElementById('messengerModal');
    if (event.target === messengerModal) {
        closeMessengerModal();
    }
}
// 메시지 전송 함수
async function sendMessage() {
    if (!currentChatRoom || !window.messengerFirestore) return;
    
    const messageInput = document.getElementById('messageInput');
    const content = messageInput.value.trim();
    
    if (!content) {
        alert('메시지를 입력해주세요.');
        return;
    }
    
    try {
        const { db, collection, addDoc, serverTimestamp } = window.messengerFirestore;
        
        // 채팅방 ID 생성
        const chatRoomId = `${currentChatRoom.day}_${currentChatRoom.zone}_${currentChatRoom.timeSlot}`.replace(/\s+/g, '_');
        
        // 메시지 데이터 생성
        const messageData = {
            chatRoomId: chatRoomId,
            day: currentChatRoom.day,
            zone: currentChatRoom.zone,
            timeSlot: currentChatRoom.timeSlot,
            author: currentUser,
            content: content,
            timestamp: serverTimestamp ? serverTimestamp() : new Date()
        };
        
        // Firestore에 메시지 추가
        await addDoc(collection(db, 'chatMessages'), messageData);
        
        // 입력 필드 초기화
        messageInput.value = '';
        
    } catch (error) {
        console.error('메시지 전송 오류:', error);
        alert('메시지 전송 중 오류가 발생했습니다: ' + error.message);
    }
}
// Enter 키로 메시지 전송 (Shift+Enter는 줄바꿈)
function handleMessageKeyPress(event) {
    if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
    }
}
// 모든 메시지 삭제 함수
async function deleteAllMessages() {
    try {
        // messengerFirestore가 없으면 초기화
        if (!window.messengerFirestore) {
            await initializeMessengerFirebase();
        }
        const { db, collection, getDocs, deleteDoc, doc } = window.messengerFirestore;
        const messagesRef = collection(db, 'chatMessages');
        const querySnapshot = await getDocs(messagesRef);
        
        const deletePromises = [];
        querySnapshot.forEach((document) => {
            deletePromises.push(deleteDoc(doc(db, 'chatMessages', document.id)));
        });
        
        await Promise.all(deletePromises);
        console.log('모든 메시지가 삭제되었습니다.');
    } catch (error) {
        console.error('메시지 삭제 오류:', error);
    }
}

// 월요일 00시 확인 및 메시지 삭제 함수
async function checkAndDeleteMessages() {
    const now = new Date();
    const dayOfWeek = now.getDay(); // 0:일, 1:월, ..., 6:토
    
    // 월요일인지 확인
    if (dayOfWeek === 1) {
        const lastDeleteDate = localStorage.getItem('lastMessageDeleteDate');
        const today = now.toDateString();
        
        // 오늘 아직 삭제하지 않았는지 확인
        if (lastDeleteDate !== today) {
            await deleteAllMessages();
            localStorage.setItem('lastMessageDeleteDate', today);
            console.log('월요일 메시지 삭제 실행');
        }
    }
}

// 앱 초기화 함수 수정
window.initializeApp = async function () {
    try {
        console.log('Initializing application...');
        setCurrentWeekDates();
        setAdminWeekDates();
        
        // 사용자와 구역을 병렬로 로드
        await Promise.all([
            loadZonesFromFirestore(),
            loadUsersFromFirestore()
        ]);
        
        populateAdminUserSelect();
        loadDataFromFirestore();
        loadNoticeFromFirestore();

        // 메시지 자동 삭제 확인 시작 (1시간마다 체크)
        setInterval(() => {
            checkAndDeleteMessages().catch(console.error);
        }, 60 * 60 * 1000); // 1시간마다 실행
        checkAndDeleteMessages().catch(console.error); // 앱 시작 시에도 한번 확인

        document.getElementById('loginName').addEventListener('keypress', function (e) {
            if (e.key === 'Enter') {
                login();
            }
        });
        
        console.log('Application initialized successfully');
    } catch (error) {
        console.error('앱 초기화 오류:', error);
        alert('애플리케이션 초기화 중 오류가 발생했습니다.');
    }
};
// 모달 외부 클릭시 닫기
window.onclick = function(event) {
    const modal = document.getElementById('messengerModal');
    if (event.target === modal) {
        closeMessengerModal();
    }
}
        // Firestore에서 사용자 목록 로드
        async function loadUsersFromFirestore() {
            if (usersLoaded) {
                console.log('Users already loaded, using cache');
                return;
            }

            try {
                console.log('Loading users from Firestore...');
                const { collection, getDocs } = window.firestoreFunctions;
                const usersRef = collection(window.db, 'users');
                const querySnapshot = await getDocs(usersRef);
                allowedUsers = [];
                querySnapshot.forEach((doc) => {
                    allowedUsers.push(doc.data().name);
                });
                usersLoaded = true;
                console.log('Loaded users from Firestore:', allowedUsers);
            } catch (error) {
                console.error('사용자 로드 오류:', error);
                alert('전도인 목록을 불러오는 중 오류가 발생했습니다.');
            }
        }
        // 24시간제를 오전/오후 형식으로 변환하는 함수
function formatTimeToAMPM(timeStr) {
    // timeStr은 "HH:MM-HH:MM" 형식
    const [start, end] = timeStr.split('-');
    const convertToAMPM = (time) => {
        const [hours, minutes] = time.split(':');
        const hourNum = parseInt(hours, 10);
        if (hourNum === 0) {
            return `오전 12:${minutes}`;
        } else if (hourNum < 12) {
            return `오전 ${hourNum}:${minutes}`;
        } else if (hourNum === 12) {
            return `오후 12:${minutes}`;
        } else {
            return `오후 ${hourNum - 12}:${minutes}`;
        }
    };
    return `${convertToAMPM(start)}-${convertToAMPM(end)}`;
}
function scrollToActiveTab() {
    const activeTab = document.querySelector('.day-tab.active');
    if (activeTab) {
        activeTab.scrollIntoView({
            behavior: 'smooth',
            inline: 'center',
            block: 'nearest'
        });
    }
}

        function invalidateUsersCache() {
            usersLoaded = false;
            console.log('Users cache invalidated');
        }

        // Firestore에서 데이터 로드
        async function loadDataFromFirestore() {
            try {
                console.log('Loading data from Firestore...');
                const { collection, onSnapshot, query, where } = window.firestoreFunctions;
                const applicantsRef = collection(window.db, 'applicants');
                const currentWeekDates = getCurrentWeekDates();
                const weekQuery = query(
                    applicantsRef,
                    where('actualDate', '>=', currentWeekDates.start),
                    where('actualDate', '<=', currentWeekDates.end)
                );

                onSnapshot(weekQuery, (querySnapshot) => {
                    console.log('Firestore snapshot received:', querySnapshot.size, 'documents');
                    initializeApplicants(); // applicants 객체 초기화

                    allApplications = [];
                    userApplications = [];

                    querySnapshot.forEach((docSnap) => {
                        const data = docSnap.data();
                        const day = docSnap.id.split('_')[1]; // 예: "2025-08-11_월요일" -> "월요일"
                        const zonesData = data.zones || {};

                        Object.keys(zonesData).forEach(zone => {
    if (applicants[day] && applicants[day][zone]) {
        const zoneTimeSlots = zonesData[zone];
        
        // 기존 시간대 구조가 아닌 경우 변환
        if (Array.isArray(zoneTimeSlots)) {
            // 구버전 데이터 처리 (시간대 없이 저장된 데이터)
            const zoneObj = zones.find(z => z.name === zone);
            if (zoneObj && zoneObj.timeSlots.length > 0) {
                applicants[day][zone][zoneObj.timeSlots[0].time] = zoneTimeSlots;
                zoneTimeSlots.forEach(name => {
                    allApplications.push({
                        id: docSnap.id,
                        name: name,
                        day: day,
                        zone: zone,
                        timeSlot: zoneObj.timeSlots[0].time,
                        actualDate: data.actualDate
                    });
                    if (name === currentUser) {
                        userApplications.push({
                            id: docSnap.id,
                            name: name,
                            day: day,
                            zone: zone,
                            timeSlot: zoneObj.timeSlots[0].time,
                            actualDate: data.actualDate
                        });
                    }
                });
            }
        } else {
            // 새로운 시간대 구조 처리
            Object.keys(zoneTimeSlots).forEach(timeSlot => {
                applicants[day][zone][timeSlot] = zoneTimeSlots[timeSlot];
                zoneTimeSlots[timeSlot].forEach(name => {
                    allApplications.push({
                        id: docSnap.id,
                        name: name,
                        day: day,
                        zone: zone,
                        timeSlot: timeSlot,
                        actualDate: data.actualDate
                    });
                    if (name === currentUser) {
                        userApplications.push({
                            id: docSnap.id,
                            name: name,
                            day: day,
                            zone: zone,
                            timeSlot: timeSlot,
                            actualDate: data.actualDate
                        });
                    }
                });
            });
        }
    }
});
                    });

                    console.log('All applications loaded:', allApplications);
                    updateDisplay();
                    if (document.getElementById('cancelModal').style.display === 'block') {
                        updateCancelList();
                    }
                    if (document.getElementById('statsModal').style.display === 'block') {
                        loadMonthlyStats();
                    }
                }, (error) => {
                    console.error('Firestore snapshot error:', error);
                    alert('데이터베이스 연결에 실패했습니다.');
                });
            } catch (error) {
                console.error('Firebase 연결 오류:', error);
                alert('데이터베이스 연결에 실패했습니다.');
            }
        }

        // Firestore에 데이터 저장
                async function saveToFirestore(name, day, zone, timeSlot) {
                    try {
                        console.log(`Saving to Firestore: ${name}, ${day}, ${zone}, ${timeSlot}`);
                        const { collection, doc, setDoc, updateDoc, arrayUnion } = window.firestoreFunctions;
                        const actualDate = getActualDateForDay(day);
                        const docId = `${actualDate}_${day}`;
                        const applicantsRef = doc(window.db, 'applicants', docId);

                        const docSnap = await window.firestoreFunctions.getDoc(applicantsRef);
                        if (docSnap.exists()) {
                            await updateDoc(applicantsRef, {
                                [`zones.${zone}.${timeSlot}`]: arrayUnion(name),
                                timestamp: new Date()
                            });
                        } else {
                            await setDoc(applicantsRef, {
                                actualDate: actualDate,
                                zones: { [zone]: { [timeSlot]: [name] } },
                                timestamp: new Date()
                            });
                        }
                        console.log(`Document saved/updated with ID: ${docId}`);
                        return true;
                    } catch (error) {
                        console.error('저장 오류:', error);
                        alert('신청 저장 중 오류가 발생했습니다.');
                        return false;
                    }
                }

        // Firestore에서 데이터 삭제
        async function deleteFromFirestore(docId, application) {
            try {
                console.log('Deleting from Firestore:', docId, application);
                const { doc, updateDoc, arrayRemove } = window.firestoreFunctions;
                const applicantsRef = doc(window.db, 'applicants', docId);
                await updateDoc(applicantsRef, {
                    [`zones.${application.zone}.${application.timeSlot}`]: arrayRemove(application.name)
                });
                console.log('Application removed successfully');
                return true;
            } catch (error) {
                console.error('삭제 오류:', error);
                alert('신청 취소 중 오류가 발생했습니다: ' + error.message);
                return false;
            }
        }

        // Firestore에 사용자 추가
        async function addUserToFirestore(name) {
            try {
                const { collection, addDoc } = window.firestoreFunctions;
                const usersRef = collection(window.db, 'users');
                await addDoc(usersRef, { name: name });
                console.log('User added:', name);
                return true;
            } catch (error) {
                console.error('사용자 추가 오류:', error);
                alert('전도인 추가 중 오류가 발생했습니다.');
                return false;
            }
        }

        // Firestore에서 사용자 삭제
        async function deleteUserFromFirestore(docId) {
            try {
                const { deleteDoc, doc } = window.firestoreFunctions;
                await deleteDoc(doc(window.db, 'users', docId));
                console.log('User deleted with ID:', docId);
                return true;
            } catch (error) {
                console.error('사용자 삭제 오류:', error);
                alert('전도인 삭제 중 오류가 발생했습니다.');
                return false;
            }
        }

        // Firestore에 구역 추가
async function addZoneToFirestore(name, schedules) {
    try {
        const { collection, addDoc } = window.firestoreFunctions;
        const zonesRef = collection(window.db, 'zones');
        
        await addDoc(zonesRef, { 
            name: name, 
            schedules: schedules
        });
        
        console.log('Zone added:', name);
        return true;
    } catch (error) {
        console.error('구역 추가 오류:', error);
        alert('구역 추가 중 오류가 발생했습니다.');
        return false;
    }
}
        // Firestore에서 구역 삭제
        async function deleteZoneFromFirestore(docId) {
            try {
                const { deleteDoc, doc } = window.firestoreFunctions;
                await deleteDoc(doc(window.db, 'zones', docId));
                console.log('Zone deleted with ID:', docId);
                return true;
            } catch (error) {
                console.error('구역 삭제 오류:', error);
                alert('구역 삭제 중 오류가 발생했습니다.');
                return false;
            }
        }

        // 로그인 함수
        async function login() {
            const name = document.getElementById('loginName').value.trim();
            if (!name) {
                alert('이름을 입력해주세요.');
                return;
            }

            if (name === 'admin') {
                currentUser = 'admin';
                isAdmin = true;
                document.getElementById('loginPage').style.display = 'none';
                document.getElementById('adminPage').style.display = 'block';
                console.log('Admin logged in');
                document.getElementById('noticeButton').style.display = 'block';
                return;
            }

            const { collection, getDocs, query, where } = window.firestoreFunctions;
            const usersRef = collection(window.db, 'users');
            const q = query(usersRef, where("name", "==", name));
            const querySnapshot = await getDocs(q);

            if (querySnapshot.empty) {
                alert('등록되지 않은 전도인입니다. 오탈자를 확인하거나, 필요 시 회중에 문의하시기 바랍니다.');
                document.getElementById('loginName').value = '';
                return;
            }

            currentUser = name;
            isAdmin = false;
            document.getElementById('userInfo').textContent = `${currentUser}님 환영합니다!`;
            document.getElementById('loginPage').style.display = 'none';
            document.getElementById('mainPage').style.display = 'block';
            document.getElementById('noticeButton').style.display = 'block';
            filterUserApplications();
            updateCancelList();
            updateDisplay();
            console.log('User logged in:', currentUser);
            // 일반 사용자 로그인 성공 시 (기존 코드 다음에 추가)
            currentUser = name;
            isAdmin = false;
            document.getElementById('userInfo').textContent = `${currentUser}님 환영합니다!`;
            document.getElementById('loginPage').style.display = 'none';
            document.getElementById('mainPage').style.display = 'block';
            filterUserApplications();
            updateCancelList();
            updateDisplay();

            // 공지사항 로드 추가
            loadNoticeFromFirestore();

            console.log('User logged in:', currentUser);
        }
// 뷰 전환 함수
function switchStatsView(view) {
    currentView = view;
    
    // 탭 활성화 상태 업데이트
    document.querySelectorAll('.stats-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    event.target.classList.add('active');
    
    // 뷰에 따라 표시 방식 변경
    if (view === 'table') {
        document.getElementById('chartContainer').style.display = 'none';
        document.getElementById('statsDisplayArea').style.display = 'block';
        
        // 현재 통계 타입에 따라 테이블 다시 표시
        if (currentStatsType === 'zone') {
            displayZoneStats();
        } else {
            displayUserStats();
        }
    } else {
        document.getElementById('chartContainer').style.display = 'block';
        document.getElementById('statsDisplayArea').style.display = 'none';
        
        // 현재 통계 타입에 따라 차트 생성
        if (currentStatsType === 'zone') {
            createZoneChart();
        } else {
            createUserChart();
        }
    }
}
        // 관리자 사용자 선택 목록 채우기
        async function populateAdminUserSelect() {
            const select = document.getElementById('adminUserSelect');
            if (!select) return;

            select.innerHTML = '<option value="">사용자를 선택하세요</option>';

            if (!usersLoaded) {
                await loadUsersFromFirestore();
            }

            allowedUsers.forEach(user => {
                const option = document.createElement('option');
                option.value = user;
                option.textContent = user;
                select.appendChild(option);
            });
            console.log('Admin user select populated from cache');
        }

        // 사용자 목록 로드 및 표시
        async function loadAndDisplayUsers() {
            const userManagementListEl = document.getElementById('userManagementList');
            userManagementListEl.innerHTML = '';

            const { collection, getDocs } = window.firestoreFunctions;
            const usersRef = collection(window.db, 'users');
            const querySnapshot = await getDocs(usersRef);

            const userCount = querySnapshot.size;
            const userListHeading = document.querySelector('#userManagementModal .user-list h3');
            userListHeading.textContent = `등록된 전도인 (총 ${userCount}명)`;

            if (querySnapshot.empty) {
                userManagementListEl.innerHTML = '<p>등록된 전도인이 없습니다.</p>';
                return;
            }

            querySnapshot.forEach((docSnap) => {
                const userData = docSnap.data();
                const userName = userData.name;
                const docId = docSnap.id;

                const userItem = document.createElement('div');
                userItem.className = 'user-item';
                userItem.innerHTML = `
                        <div class="user-name">${userName}</div>
                        <button class="btn danger small" onclick="deleteUser('${docId}', '${userName}')">삭제</button>
                    `;
                userManagementListEl.appendChild(userItem);
            });
        }

        // 새 사용자 추가
        async function addNewUser() {
            const name = document.getElementById('newUserName').value.trim();
            if (!name) {
                alert('이름을 입력해주세요.');
                return;
            }

            const { collection, getDocs, query, where } = window.firestoreFunctions;
            const usersRef = collection(window.db, 'users');
            const q = query(usersRef, where("name", "==", name));
            const querySnapshot = await getDocs(q);

            if (!querySnapshot.empty) {
                alert('이미 등록된 전도인입니다.');
                return;
            }

            const added = await addUserToFirestore(name);
            if (added) {
                alert(`${name}님이 추가되었습니다.`);
                document.getElementById('newUserName').value = '';
                invalidateUsersCache();
                loadUsersFromFirestore();
                populateAdminUserSelect();
                loadAndDisplayUsers();
            }
        }

        // 사용자 삭제
        async function deleteUser(docId, userName) {
            if (confirm(`${userName}님을 삭제하시겠습니까?`)) {
                const deleted = await deleteUserFromFirestore(docId);
                if (deleted) {
                    alert(`${userName}님이 삭제되었습니다.`);
                    invalidateUsersCache();
                    loadUsersFromFirestore();
                    populateAdminUserSelect();
                    loadAndDisplayUsers();
                }
            }
        }

        // 구역 목록 로드 및 표시
        async function loadAndDisplayZones() {
            const zoneManagementListEl = document.getElementById('zoneManagementList');
            zoneManagementListEl.innerHTML = '';

            const { collection, getDocs } = window.firestoreFunctions;
            const zonesRef = collection(window.db, 'zones');
            const querySnapshot = await getDocs(zonesRef);

            if (querySnapshot.empty) {
                zoneManagementListEl.innerHTML = '<p>등록된 구역이 없습니다.</p>';
                return;
            }

            querySnapshot.forEach((docSnap) => {
                const zoneData = docSnap.data();
                const zoneName = zoneData.name;
                const maxCapacity = zoneData.maxCapacity;
                const docId = docSnap.id;

                const zoneItem = document.createElement('div');
                zoneItem.className = 'user-item';
                zoneItem.innerHTML = `
                    <div class="user-name">${zoneName}</div>
                    <div>
                        <button class="btn success small" onclick="editZone('${docId}', '${zoneName}')">수정</button>
                        <button class="btn danger small" onclick="deleteZone('${docId}', '${zoneName}')">삭제</button>
                    </div>
                `;
                zoneManagementListEl.appendChild(zoneItem);
            });
        }

        // 새 구역 추가
// 새 구역 추가 (수정된 버전)
async function addNewZone() {
    const name = document.getElementById('newZoneName').value.trim();
    
    if (!name) {
        alert('구역 이름을 입력해주세요.');
        return;
    }
    
    // 모든 스케줄 데이터 수집
    const schedules = [];
    const scheduleElements = document.querySelectorAll('.schedule-item');
    
    for (const scheduleElement of scheduleElements) {
        // 선택된 요일 수집
        const selectedDays = [];
        const dayCheckboxes = scheduleElement.querySelectorAll('input[type="checkbox"]:checked');
        dayCheckboxes.forEach(checkbox => {
            selectedDays.push(checkbox.value);
        });
        
        if (selectedDays.length === 0) continue; // 요일이 선택되지 않은 스케줄 건너뛰기
        
        // 시간대 수집
        const timeSlots = [];
        const timeSlotElements = scheduleElement.querySelectorAll('.time-slot-item');
        
        for (const timeSlotElement of timeSlotElements) {
            const startHour = timeSlotElement.querySelector('.start-hour').value;
            const startMinute = timeSlotElement.querySelector('.start-minute').value;
            const endHour = timeSlotElement.querySelector('.end-hour').value;
            const endMinute = timeSlotElement.querySelector('.end-minute').value;
            const capacity = parseInt(timeSlotElement.querySelector('.capacity-input').value);
            
            const timeText = `${startHour}:${startMinute}-${endHour}:${endMinute}`;
            
            timeSlots.push({
                time: timeText,
                maxCapacity: capacity,
                isActive: true
            });
        }
        
        if (timeSlots.length > 0) {
            schedules.push({
                days: selectedDays,
                timeSlots: timeSlots
            });
        }
    }
    
    if (schedules.length === 0) {
        alert('최소 하나의 유효한 일정을 설정해주세요.');
        return;
    }
    
    // 기존 구역명 중복 검사
    const existingZone = zones.find(zone => zone.name === name);
    if (existingZone) {
        alert('이미 존재하는 구역 이름입니다.');
        return;
    }
    
    const added = await addZoneToFirestore(name, schedules);
    if (added) {
        alert(`${name} 구역이 추가되었습니다.`);
        document.getElementById('newZoneName').value = '';
        document.getElementById('schedulesContainer').innerHTML = '';
        initSchedulesContainer(); // 스케줄 컨테이너 초기화
        loadZonesFromFirestore();
        loadAndDisplayZones();
    }
}
        // 구역 삭제
        async function deleteZone(docId, zoneName) {
            if (confirm(`${zoneName} 구역을 삭제하시겠습니까?`)) {
                const deleted = await deleteZoneFromFirestore(docId);
                if (deleted) {
                    alert(`${zoneName} 구역이 삭제되었습니다.`);
                    loadZonesFromFirestore();
                    loadAndDisplayZones();
                }
            }
        }

        // 신청 모달 열기
        function openRegistrationModal() {
            document.getElementById('registrationModal').style.display = 'block';
            setCurrentWeekDates();
            updateDaySelectionModal();
            updateZoneDisplayForModal();
            console.log('Registration modal opened');
        }

        // 신청 모달 닫기
        function closeRegistrationModal() {
            document.getElementById('registrationModal').style.display = 'none';
            document.getElementById('registrationForm').reset();
            document.getElementById('zoneSelectionContainer').classList.remove('show');
            document.getElementById('timeSelectionContainer').classList.remove('show');
            console.log('Registration modal closed');
        }

        // 신청 취소 모달 열기
        function openCancelModal() {
            document.getElementById('cancelModal').style.display = 'block';
            filterUserApplications();
            updateCancelList();
            console.log('Cancel modal opened');
        }

        // 신청 취소 모달 닫기
        function closeCancelModal() {
            document.getElementById('cancelModal').style.display = 'none';
            console.log('Cancel modal closed');
        }

        // 사용자 관리 모달 열기
        function openUserManagementModal() {
            document.getElementById('userManagementModal').style.display = 'block';
            loadAndDisplayUsers();
            populateAdminUserSelect();
            console.log('User management modal opened');
        }

        // 사용자 관리 모달 닫기
        function closeUserManagementModal() {
            document.getElementById('userManagementModal').style.display = 'none';
            console.log('User management modal closed');
        }

        // 구역 관리 모달 열기
function openZoneManagementModal() {
    document.getElementById('zoneManagementModal').style.display = 'block';
    loadAndDisplayZones();
    initSchedulesContainer();
    console.log('Zone management modal opened');
}
// 스케줄 컨테이너 초기화
function initSchedulesContainer() {
    const container = document.getElementById('schedulesContainer');
    container.innerHTML = '';
    addNewSchedule(); // 기본으로 하나의 스케줄 추가
}

// 새 스케줄 추가
function addNewSchedule() {
    const container = document.getElementById('schedulesContainer');
    const scheduleId = Date.now(); // 고유 ID 생성
    
    const scheduleDiv = document.createElement('div');
    scheduleDiv.className = 'schedule-item';
    scheduleDiv.id = `schedule-${scheduleId}`;
    
    scheduleDiv.innerHTML = `
        <div class="schedule-header">
            <div class="schedule-title">일정 #${container.children.length + 1}</div>
            <button type="button" class="remove-schedule" onclick="removeSchedule(${scheduleId})">삭제</button>
        </div>
        
        <div class="form-group">
            <label>요일 선택</label>
            <div class="day-selection-grid">
                <div class="day-checkbox">
                    <input type="checkbox" id="mon-${scheduleId}" value="월요일">
                    <label for="mon-${scheduleId}">월요일</label>
                </div>
                <div class="day-checkbox">
                    <input type="checkbox" id="tue-${scheduleId}" value="화요일">
                    <label for="tue-${scheduleId}">화요일</label>
                </div>
                <div class="day-checkbox">
                    <input type="checkbox" id="wed-${scheduleId}" value="수요일">
                    <label for="wed-${scheduleId}">수요일</label>
                </div>
                <div class="day-checkbox">
                    <input type="checkbox" id="thu-${scheduleId}" value="목요일">
                    <label for="thu-${scheduleId}">목요일</label>
                </div>
                <div class="day-checkbox">
                    <input type="checkbox" id="fri-${scheduleId}" value="금요일">
                    <label for="fri-${scheduleId}">금요일</label>
                </div>
                <div class="day-checkbox">
                    <input type="checkbox" id="sat-${scheduleId}" value="토요일">
                    <label for="sat-${scheduleId}">토요일</label>
                </div>
                <div class="day-checkbox">
                    <input type="checkbox" id="sun-${scheduleId}" value="일요일">
                    <label for="sun-${scheduleId}">일요일</label>
                </div>
            </div>
        </div>
        
        <div class="form-group">
            <label>시간대 설정</label>
            <div class="time-slot-settings" id="timeSlots-${scheduleId}">
                <div class="empty-time-slots">시간대를 추가해주세요</div>
            </div>
            <div class="time-slot-controls">
                <button type="button" class="btn secondary small" onclick="addTimeSlotToSchedule(${scheduleId})">시간대 추가</button>
            </div>
        </div>
    `;
    
    container.appendChild(scheduleDiv);
}

// 스케줄 삭제
function removeSchedule(scheduleId) {
    const scheduleDiv = document.getElementById(`schedule-${scheduleId}`);
    if (scheduleDiv && confirm('이 일정을 삭제하시겠습니까?')) {
        scheduleDiv.remove();
        // 남은 스케줄 번호 재설정
        const schedules = document.querySelectorAll('.schedule-item');
        schedules.forEach((schedule, index) => {
            schedule.querySelector('.schedule-title').textContent = `일정 #${index + 1}`;
        });
    }
}

// 스케줄에 시간대 추가
function addTimeSlotToSchedule(scheduleId) {
    const container = document.getElementById(`timeSlots-${scheduleId}`);
    
    // 빈 메시지 제거
    if (container.querySelector('.empty-time-slots')) {
        container.innerHTML = '';
    }
    
    const timeSlotDiv = document.createElement('div');
    timeSlotDiv.className = 'time-slot-item';
    
    timeSlotDiv.innerHTML = `
        <div class="time-slot-row">
            <div class="time-input-group">
                <label class="time-input-label">시작 시간</label>
                <div class="time-picker-container">
                    <div class="time-picker">
                        <select class="time-select start-hour">
                            ${generateHourOptions('09')}
                        </select>
                        <span>:</span>
                        <select class="time-select start-minute">
                            ${generateMinuteOptions('00')}
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="time-input-group">
                <label class="time-input-label">종료 시간</label>
                <div class="time-picker-container">
                    <div class="time-picker">
                        <select class="time-select end-hour">
                            ${generateHourOptions('12')}
                        </select>
                        <span>:</span>
                        <select class="time-select end-minute">
                            ${generateMinuteOptions('00')}
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="time-input-group">
                <label class="time-input-label">최대 인원</label>
                <input type="number" class="capacity-input" value="4" min="1" max="20">
            </div>
            
            <div class="time-input-group">
                <button type="button" class="btn remove-time" onclick="this.parentElement.parentElement.parentElement.remove()">삭제</button>
            </div>
        </div>
    `;
    
    container.appendChild(timeSlotDiv);
}

        // 구역 관리 모달 닫기
        function closeZoneManagementModal() {
            document.getElementById('zoneManagementModal').style.display = 'none';
            console.log('Zone management modal closed');
        }

function displayZoneStats() {
    currentStatsType = 'zone';
    
    if (currentView === 'table') {
  const display = document.getElementById('statsDisplayArea');
  display.innerHTML = '';

  const zoneMap = new Map();
  // zones 배열이 있으면 미리 채우고, 없으면 데이터에서 동적 생성
  if (Array.isArray(zones) && zones.length) {
    zones.forEach(z => zoneMap.set(z.name, new Map()));
  }
  monthlyData.forEach(({ name, zone }) => {
    if (!zoneMap.has(zone)) zoneMap.set(zone, new Map());
    const userMap = zoneMap.get(zone);
    userMap.set(name, (userMap.get(name) || 0) + 1);
  });

  const table = document.createElement('table');
  table.style.width = '100%';
  table.style.borderCollapse = 'collapse';

  const thead = document.createElement('thead');
  thead.innerHTML =
    '<tr>' +
      '<th style="border:1px solid #ddd;padding:8px;background:#f0f0f0;">구역</th>' +
      '<th style="border:1px solid #ddd;padding:8px;background:#f0f0f0;">요약</th>' +
      '<th style="border:1px solid #ddd;padding:8px;background:#f0f0f0;">참여자 (횟수)</th>' +
    '</tr>';
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  zoneMap.forEach((userMap, zone) => {
    const row = document.createElement('tr');

    const zoneCell = document.createElement('td');
    zoneCell.textContent = zone;
    zoneCell.style.border = '1px solid #ddd';
    zoneCell.style.padding = '8px';

    const summaryCell = document.createElement('td');
    const distinct = userMap.size; // 참여 인원 수
    const total = Array.from(userMap.values()).reduce((a, b) => a + b, 0); // 총 신청 횟수
    summaryCell.textContent = `${distinct}명 / ${total}회`;
    summaryCell.style.border = '1px solid #ddd';
    summaryCell.style.padding = '8px';

    const usersCell = document.createElement('td');
    usersCell.style.border = '1px solid #ddd';
    usersCell.style.padding = '8px';
    usersCell.innerHTML = userMap.size
      ? Array.from(userMap.entries()).map(([u, c]) => `${u} (${c}회)`).join('<br>')
      : '참여자 없음';

    row.appendChild(zoneCell);
    row.appendChild(summaryCell);
    row.appendChild(usersCell);
    tbody.appendChild(row);
  });

  table.appendChild(tbody);
  display.appendChild(table);
}else {
        createZoneChart();
    }
}



function displayUserStats() {
    currentStatsType = 'user';
    
    if (currentView === 'table') {
  const displayArea = document.getElementById('statsDisplayArea');
  displayArea.innerHTML = '';

  // {user: Map(zone -> count)}
  const userMap = new Map();

  monthlyData.forEach(({ name, zone }) => {
    if (!userMap.has(name)) userMap.set(name, new Map());
    const zmap = userMap.get(name);
    zmap.set(zone, (zmap.get(zone) || 0) + 1);
  });

  const table = document.createElement('table');
  table.style.width = '100%';
  table.style.borderCollapse = 'collapse';

  const thead = document.createElement('thead');
  thead.innerHTML =
    '<tr>' +
      '<th style="border:1px solid #ddd;padding:8px;background:#f0f0f0;">개인</th>' +
      '<th style="border:1px solid #ddd;padding:8px;background:#f0f0f0;">구역 (횟수)</th>' +
    '</tr>';
  table.appendChild(thead);

  const tbody = document.createElement('tbody');
  userMap.forEach((zmap, user) => {
    const row = document.createElement('tr');

    const userCell = document.createElement('td');
    userCell.textContent = user;
    userCell.style.border = '1px solid #ddd';
    userCell.style.padding = '8px';

    const zonesCell = document.createElement('td');
    zonesCell.style.border = '1px solid #ddd';
    zonesCell.style.padding = '8px';
    zonesCell.innerHTML = zmap.size
      ? Array.from(zmap.entries()).map(([z, c]) => `${z} (${c}회)`).join('<br>')
      : '참여 구역 없음';

    row.appendChild(userCell);
    row.appendChild(zonesCell);
    tbody.appendChild(row);
  });

  table.appendChild(tbody);
  displayArea.appendChild(table);
}else {
        createUserChart();
    }
}
// 구역별 차트 생성 함수
function createZoneChart() {
    const ctx = document.getElementById('statsChart').getContext('2d');
    
    // 기존 차트 제거
    if (currentChart) {
        currentChart.destroy();
    }
    
    const zoneMap = new Map();
    // zones 배열이 있으면 미리 채우고, 없으면 데이터에서 동적 생성
    if (Array.isArray(zones) && zones.length) {
        zones.forEach(z => zoneMap.set(z.name, new Map()));
    }
    monthlyData.forEach(({ name, zone }) => {
        if (!zoneMap.has(zone)) zoneMap.set(zone, new Map());
        const userMap = zoneMap.get(zone);
        userMap.set(name, (userMap.get(name) || 0) + 1);
    });
    
    // 차트 데이터 준비
    const labels = Array.from(zoneMap.keys());
    const participantData = labels.map(zone => zoneMap.get(zone).size);
    const totalData = labels.map(zone => 
        Array.from(zoneMap.get(zone).values()).reduce((a, b) => a + b, 0)
    );
    
    // 차트 생성
    currentChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [
                {
                    label: '참여 인원 수',
                    data: participantData,
                    backgroundColor: 'rgba(54, 162, 235, 0.5)',
                    borderColor: 'rgba(54, 162, 235, 1)',
                    borderWidth: 1
                },
                {
                    label: '총 참여 횟수',
                    data: totalData,
                    backgroundColor: 'rgba(255, 99, 132, 0.5)',
                    borderColor: 'rgba(255, 99, 132, 1)',
                    borderWidth: 1
                }
            ]
        },
        options: {
            responsive: true,
            plugins: {
                title: {
                    display: true,
                    text: '구역별 참여 현황'
                },
            },
            scales: {
                y: {
                    beginAtZero: true
                }
            }
        }
    });
}

// 사용자별 차트 생성 함수
function createUserChart() {
    const ctx = document.getElementById('statsChart').getContext('2d');
    
    // 기존 차트 제거
    if (currentChart) {
        currentChart.destroy();
    }
    
    // {user: Map(zone -> count)}
    const userMap = new Map();
    monthlyData.forEach(({ name, zone }) => {
        if (!userMap.has(name)) userMap.set(name, new Map());
        const zmap = userMap.get(name);
        zmap.set(zone, (zmap.get(zone) || 0) + 1);
    });
    
    // 상위 10명만 표시 (너무 많으면 차트가 복잡해짐)
    const topUsers = Array.from(userMap.entries())
        .sort((a, b) => {
            const totalA = Array.from(a[1].values()).reduce((sum, count) => sum + count, 0);
            const totalB = Array.from(b[1].values()).reduce((sum, count) => sum + count, 0);
            return totalB - totalA;
        })
        .slice(0, 10);
    
    const labels = topUsers.map(([user]) => user);
    const data = topUsers.map(([user, zones]) => 
        Array.from(zones.values()).reduce((sum, count) => sum + count, 0)
    );
    
    // 차트 생성
    currentChart = new Chart(ctx, {
        type: 'bar',
        data: {
            labels: labels,
            datasets: [{
                label: '참여 횟수',
                data: data,
                backgroundColor: 'rgba(75, 192, 192, 0.5)',
                borderColor: 'rgba(75, 192, 192, 1)',
                borderWidth: 1
            }]
        },
        options: {
            responsive: true,
            plugins: {
                title: {
                    display: true,
                    text: '개인별 참여 현황 (상위 10명)'
                },
            },
            scales: {
                y: {
                    beginAtZero: true
                }
            }
        }
    });
}

// 월 변경 시 차트도 업데이트
function changeMonth(direction) {
    currentStatsMonth += direction;
    if (currentStatsMonth > 12) {
        currentStatsMonth = 1;
        currentStatsYear += 1;
    } else if (currentStatsMonth < 1) {
        currentStatsMonth = 12;
        currentStatsYear -= 1;
    }
    loadMonthlyStats();
    
    // 차트 보기 중이면 차트도 업데이트
    if (currentView === 'chart') {
        if (currentStatsType === 'zone') {
            createZoneChart();
        } else {
            createUserChart();
        }
    }
}




        // 데이터 통계 모달 닫기
        function closeStatsModal() {
            document.getElementById('statsModal').style.display = 'none';
            console.log('Stats modal closed');
        }

        // 월간 통계 로드
async function loadMonthlyStats() {
  try {
    const { collection, getDocs, query, where } = window.firestoreFunctions;
    const applicantsRef = collection(window.db, 'applicants');

    // 이번 달 1일~말일
    const startDate = new Date(currentStatsYear, currentStatsMonth - 1, 1);
    const endDate   = new Date(currentStatsYear, currentStatsMonth, 0);
    const startDateStr = getLocalDateString(startDate);
    const endDateStr   = getLocalDateString(endDate);

    const monthQuery = query(
      applicantsRef,
      where('actualDate', '>=', startDateStr),
      where('actualDate', '<=', endDateStr)
    );

    const snap = await getDocs(monthQuery);

    // 전역 배열 재사용(중요! const로 새로 만들지 말기)
    monthlyData = [];

    // Firestore 문서에서 이름/구역만 뽑아서 Push
    snap.forEach(doc => {
      const data = doc.data();
      const zonesData = data.zones || {};
      Object.keys(zonesData).forEach(zone => {
        const timeSlots = zonesData[zone] || {};
        Object.values(timeSlots).forEach(applicantList => {
          (applicantList || []).forEach(name => {
            monthlyData.push({ name, zone }); // 시간/요일 버림
          });
        });
      });
    });

    // 상단 월 표시
    const monthEl = document.getElementById('currentMonth');
    if (monthEl) {
      monthEl.textContent = `${currentStatsYear}년 ${currentStatsMonth}월`;
    }

    // 기본 탭: 구역별
    displayZoneStats();

    // 데이터 없을 때 메시지
    if (monthlyData.length === 0) {
      document.getElementById('statsDisplayArea').innerHTML =
        '<p style="text-align:center;color:#a0aec0;">해당 월에 데이터가 없습니다.</p>';
    }
  } catch (e) {
    console.error('통계 데이터 로드 오류:', e);
    document.getElementById('statsDisplayArea').innerHTML =
      '<p style="text-align:center;color:#e53e3e;">데이터 로드 실패</p>';
    alert(`통계 데이터를 불러오는 중 오류가 발생했습니다: ${e.message}`);
  }
}


        // 로컬 날짜 문자열 생성 함수
        function getLocalDateString(date) {
            return `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
        }
        // 시간대 겹침 확인 함수 (완전히 새로 추가)
function isOverlapping(newTime, existingTime) {
    // 시간 문자열 "HH:MM-HH:MM"을 분 단위로 변환
    function timeToMinutes(timeStr) {
        const [hours, minutes] = timeStr.split(':').map(Number);
        return hours * 60 + minutes;
    }

    // 새 시간대의 시작/종료 시간
    const [newStart, newEnd] = newTime.split('-').map(timeToMinutes);
    
    // 기존 시간대의 시작/종료 시간
    const [existStart, existEnd] = existingTime.split('-').map(timeToMinutes);
    
    // 겹침 조건: 새 시작 시간이 기존 종료 시간보다 작거나 같고, 새 종료 시간이 기존 시작 시간보다 크거나 같음
    return newStart <= existEnd && newEnd >= existStart;
}

        // 월 변경
 function changeMonth(direction) {
    currentStatsMonth += direction;
    if (currentStatsMonth > 12) {
        currentStatsMonth = 1;
        currentStatsYear += 1;
    } else if (currentStatsMonth < 1) {
        currentStatsMonth = 12;
        currentStatsYear -= 1;
    }
    loadMonthlyStats();
}

        // 현재 주의 날짜 범위 계산
        function getCurrentWeekDates() {
    const today = new Date();
    const currentDay = today.getDay();
    
    // 월요일을 주의 시작으로 설정
    // 일요일(0)인 경우 -6, 월요일(1)인 경우 0, ... 토요일(6)인 경우 -5
    const monday = new Date(today);
    monday.setDate(today.getDate() - (currentDay === 0 ? 6 : currentDay - 1));
    
    const sunday = new Date(monday);
    sunday.setDate(monday.getDate() + 6);
    
    return {
        start: getLocalDateString(monday),
        end: getLocalDateString(sunday)
    };
}


        // 특정 요일의 실제 날짜 계산
function getActualDateForDay(dayName) {
    const today = new Date();
    const currentDay = today.getDay();
    
    // 월요일을 주의 시작으로 설정
    const monday = new Date(today);
    monday.setDate(today.getDate() - (currentDay === 0 ? 6 : currentDay - 1));
    
    const dayMap = {
        '월요일': 0,
        '화요일': 1,
        '수요일': 2,
        '목요일': 3,
        '금요일': 4,
        '토요일': 5,
        '일요일': 6
    };
    
    const targetDate = new Date(monday);
    targetDate.setDate(monday.getDate() + dayMap[dayName]);
    return getLocalDateString(targetDate);
}


        // 현재 주의 각 요일 날짜 설정
function setCurrentWeekDates() {
    const today = new Date();
    const currentDay = today.getDay();
    
    const monday = new Date(today);
    monday.setDate(today.getDate() - (currentDay === 0 ? 6 : currentDay - 1));
    
    const dayMap = {
        '월요일': 0,
        '화요일': 1,
        '수요일': 2,
        '목요일': 3,
        '금요일': 4,
        '토요일': 5,
        '일요일': 6
    };
    
    // 활성화된 요일만 처리
    const activeDays = getActiveDays();
    activeDays.forEach(day => {
        const date = new Date(monday);
        date.setDate(monday.getDate() + dayMap[day]);
        const dateString = `${date.getMonth() + 1}/${date.getDate()}`;
        
        const element = document.getElementById(`${day.toLowerCase().replace('요일', '')}-date`);
        if (element) {
            element.textContent = dateString;
        }
    });
    
    console.log('Current week dates set for active days');
}

        // 관리자 요일 날짜 설정
function setAdminWeekDates() {
    const today = new Date();
    const currentDay = today.getDay();
    
    // 월요일을 주의 시작으로 설정
    const monday = new Date(today);
    monday.setDate(today.getDate() - (currentDay === 0 ? 6 : currentDay - 1));
    
    const dayElements = [
        { id: 'admin-monday-date', offset: 0 },
        { id: 'admin-tuesday-date', offset: 1 },
        { id: 'admin-wednesday-date', offset: 2 },
        { id: 'admin-thursday-date', offset: 3 },
        { id: 'admin-friday-date', offset: 4 },
        { id: 'admin-saturday-date', offset: 5 },
        { id: 'admin-sunday-date', offset: 6 } // 일요일 추가
    ];
    
    dayElements.forEach(day => {
        const date = new Date(monday);
        date.setDate(monday.getDate() + day.offset);
        const dateString = `${date.getMonth() + 1}/${date.getDate()}`;
        const element = document.getElementById(day.id);
        if (element) {
            element.textContent = dateString;
        }
    });
    console.log('Admin week dates set');
}
// 활성화된 요일 목록을 반환하는 함수
function getActiveDays() {
    const activeDays = new Set();
    zones.forEach(zone => {
        if (zone.schedules) {
            zone.schedules.forEach(schedule => {
                if (schedule.days) {
                    schedule.days.forEach(day => {
                        activeDays.add(day);
                    });
                }
            });
        }
    });
    return Array.from(activeDays);
}

        // 사용자 신청 필터링
        function filterUserApplications() {
            if (!currentUser || isAdmin) {
                userApplications = [];
                return;
            }
            userApplications = allApplications.filter(a => a.name === currentUser);
            console.log('Filtered user applications:', userApplications);
        }
// 신청 모달의 요일 선택 UI를 업데이트하는 함수
function updateDaySelectionModal() {
    const daySelection = document.querySelector('.day-selection');
    if (!daySelection) return;

    const activeDays = getActiveDays();
    daySelection.innerHTML = '';

    activeDays.forEach(day => {
        const dayOption = document.createElement('div');
        dayOption.className = 'day-option';
        
        const dayId = day.toLowerCase().replace('요일', '');
        const dateInfo = document.getElementById(`${dayId}-date`)?.textContent || '';
        
        dayOption.innerHTML = `
            <input type="radio" id="${dayId}" name="day" value="${day}">
            <label for="${dayId}" class="day-label" data-day="${day}">
                ${day}
                <div class="date-info" id="${dayId}-date">${dateInfo}</div>
            </label>
        `;
        
        daySelection.appendChild(dayOption);
    });

    // 변경 사항에 대한 이벤트 리스너 다시 등록
    attachDaySelectionListeners();
}

// 요일 선택 이벤트 리스너를 다시 연결하는 함수
function attachDaySelectionListeners() {
    document.querySelectorAll('input[name="day"]').forEach(radio => {
        radio.addEventListener('change', function() {
            const zoneContainer = document.getElementById('zoneSelectionContainer');
            if (this.checked) {
                zoneContainer.classList.add('show');
                setTimeout(() => {
                    zoneContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 100);
                updateZoneDisplay(this.value);
                document.querySelectorAll('input[name="zone"]').forEach(zoneRadio => {
                    zoneRadio.checked = false;
                });
            }
        });
    });
}
        // 신청 취소 목록 업데이트
        function updateCancelList() {
            const cancelListEl = document.getElementById('cancelList');
            cancelListEl.innerHTML = '';

            if (userApplications.length === 0) {
                const noApplicationsDiv = document.createElement('div');
                noApplicationsDiv.className = 'no-applications';
                noApplicationsDiv.textContent = '신청 내역이 없습니다.';
                cancelListEl.appendChild(noApplicationsDiv);
                console.log('No user applications to display in cancel list');
                return;
            }

            userApplications.forEach(application => {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'cancel-item';

                const infoDiv = document.createElement('div');
                infoDiv.className = 'cancel-info';

                const dayDiv = document.createElement('div');
                dayDiv.className = 'cancel-day';
                dayDiv.textContent = application.day;

                const detailsDiv = document.createElement('div');
                detailsDiv.className = 'cancel-details';
                const dateParts = application.actualDate.split('-');
                const date = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
                const dateString = `${date.getFullYear()}/${date.getMonth() + 1}/${date.getDate()}`;
                detailsDiv.textContent = `${dateString} • ${application.zone} • ${application.timeSlot || '시간미지정'}`;

                infoDiv.appendChild(dayDiv);
                infoDiv.appendChild(detailsDiv);

                const cancelBtn = document.createElement('button');
                cancelBtn.className = 'btn danger';
                cancelBtn.textContent = '취소';
                cancelBtn.onclick = () => confirmCancelApplication(application);

                itemDiv.appendChild(infoDiv);
                itemDiv.appendChild(cancelBtn);
                cancelListEl.appendChild(itemDiv);
            });
            console.log('User cancel list updated with', userApplications.length, 'items');
        }

        // 신청 취소 확인
        function confirmCancelApplication(application) {
            const dateParts = application.actualDate.split('-');
            const date = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
            const dateString = `${date.getFullYear()}/${date.getMonth() + 1}/${date.getDate()}`;
            const confirmMessage = `${application.day}(${dateString}) ${application.zone} 전시대 봉사 신청을 취소하시겠습니까?`;

            if (confirm(confirmMessage)) {
                cancelApplication(application.id, application);
            }
        }

// 날씨 정보 열기 함수 (기상청 API)
async function openWeather() {
    const xy = dfs_xy_conv("toXY", 37.6027, 126.9292); // 서울 은평구
    const now = new Date();
    let base_date = now.getFullYear().toString() +
                    ("0" + (now.getMonth() + 1)).slice(-2) +
                    ("0" + now.getDate()).slice(-2);
    
    const available_times = ["0200", "0500", "0800", "1100", "1400", "1700", "2000", "2300"];
    let current_hour = ("0" + now.getHours()).slice(-2);
    let base_time = "";

    for (let i = available_times.length - 1; i >= 0; i--) {
        if (current_hour >= available_times[i].substring(0, 2)) {
            base_time = available_times[i];
            break;
        }
    }
    if (base_time === "") {
        now.setDate(now.getDate() - 1);
        base_date = now.getFullYear().toString() +
                    ("0" + (now.getMonth() + 1)).slice(-2) +
                    ("0" + now.getDate()).slice(-2);
        base_time = "2300";
    }

    const apiUrl = `https://apis.data.go.kr/1360000/VilageFcstInfoService_2.0/getVilageFcst?serviceKey=${KMA_API_KEY}&pageNo=1&numOfRows=1000&dataType=JSON&base_date=${base_date}&base_time=${base_time}&nx=${xy.x}&ny=${xy.y}`;

    try {
        const response = await fetch(apiUrl);
        if (!response.ok) throw new Error(`API 요청 실패: ${response.status}`);
        const data = await response.json();
        
        if (data.response.header.resultCode !== "00") {
            throw new Error(`API 오류: ${data.response.header.resultMsg}`);
        }
        
        const dailyData = processKmaData(data.response.body.items.item);
        createWeatherModal(dailyData);

    } catch (error) {
        console.error("날씨 정보를 가져오는 중 오류가 발생했습니다:", error);
        alert(`날씨 정보를 가져오는 데 실패했습니다: ${error.message}`);
    }
}

function processKmaData(items) {
    const daily = {};

    items.forEach(item => {
        const date = item.fcstDate;
        if (!daily[date]) {
            daily[date] = {
                dt: new Date(date.substring(0,4), date.substring(4,6) - 1, date.substring(6,8)),
                temp_min: null,
                temp_max: null,
                sky: null, 
                pty: null, 
            };
        }
        
        if (item.category === 'TMX') daily[date].temp_max = parseFloat(item.fcstValue);
        if (item.category === 'TMN') daily[date].temp_min = parseFloat(item.fcstValue);
        
        // 정오(12시)의 날씨를 대표로 사용하되, 만약 정오 데이터가 없다면 그 시간대의 SKY/PTY를 사용 (가장 중요한 대표 날씨)
        if (item.fcstTime === "1200" || (!daily[date].sky && !daily[date].pty)) { // 12시 데이터 우선, 없으면 첫 데이터
            if (item.category === 'SKY') daily[date].sky = parseInt(item.fcstValue);
            if (item.category === 'PTY') daily[date].pty = parseInt(item.fcstValue);
        }
    });
    
    // 오늘 최저기온은 이미 발표되었으므로, 현재 기온으로 대체 (더 정확)
    // KMA API는 TMN/TMX를 포함하지만, 당일 TMN은 보통 밤에 나타남.
    // 현재 기온(TMP)을 받아와 당일 최저/최고 기온과 비교하여 더 정확한 값을 설정
    const todayKey = Object.keys(daily)[0];
    if (todayKey && daily[todayKey]) {
        const currentTempItem = items.find(i => i.category === 'TMP' && i.fcstDate === todayKey);
        if (currentTempItem) {
            const currentTemp = parseFloat(currentTempItem.fcstValue);
            if (daily[todayKey].temp_min === null || currentTemp < daily[todayKey].temp_min) {
                daily[todayKey].temp_min = currentTemp;
            }
            if (daily[todayKey].temp_max === null || currentTemp > daily[todayKey].temp_max) {
                daily[todayKey].temp_max = currentTemp;
            }
        }
    }


    return Object.values(daily).filter(day => day.temp_max !== null && day.temp_min !== null && day.sky !== null);
}

// 날씨 상태 코드와 아이콘 및 배경 정보 매핑하는 함수 (배경 이미지 URL 추가)
function getWeatherInfo(sky, pty) {
    let description = "정보 없음";
    let icon = "❓";
    let backgroundClass = "default-bg"; // 기본 배경 클래스

    if (pty === 0) { // 강수 없음
        if (sky === 1) { description = "맑음"; icon = "☀️"; backgroundClass = "clear-bg"; } // 맑음
        else if (sky === 3) { description = "구름많음"; icon = "☁️"; backgroundClass = "cloudy-bg"; } // 구름많음
        else if (sky === 4) { description = "흐림"; icon = "🌫️"; backgroundClass = "overcast-bg"; } // 흐림
    } else if (pty === 1) { description = "비"; icon = "🌧️"; backgroundClass = "rain-bg"; } // 비
    else if (pty === 2) { description = "비/눈"; icon = "🌨️"; backgroundClass = "sleet-bg"; } // 비/눈
    else if (pty === 3) { description = "눈"; icon = "❄️"; backgroundClass = "snow-bg"; } // 눈
    else if (pty === 4) { description = "소나기"; icon = "🌦️"; backgroundClass = "shower-bg"; } // 소나기
    
    return { description, icon, backgroundClass };
}

// 모달 생성 함수 (기상청 데이터에 맞게 수정)
function createWeatherModal(dailyForecasts) {
    const existingModal = document.querySelector('.weather-modal-overlay');
    if (existingModal) existingModal.remove();

    const overlay = document.createElement('div');
    overlay.className = 'weather-modal-overlay';
    
    const modalContent = document.createElement('div');
    modalContent.className = 'weather-modal-content';

    // 첫째 날의 날씨 정보로 모달 전체의 배경 클래스 설정
    if (dailyForecasts.length > 0) {
        const todayWeather = getWeatherInfo(dailyForecasts[0].sky, dailyForecasts[0].pty);
        modalContent.classList.add(todayWeather.backgroundClass);
    }


    modalContent.innerHTML = `
        <div class="modal-header">
            <h2>이번 주 은평구 날씨</h2>
            <button class="close-button">&times;</button>
        </div>
        <div class="forecast-container"></div>
    `;

    const forecastContainer = modalContent.querySelector('.forecast-container');
    // 최대 7일치 예보만 표시
    dailyForecasts.slice(0, 7).forEach(day => {
        const date = day.dt;
        const dayOfWeek = date.toLocaleString('ko-KR', { weekday: 'short' });
        const monthDay = date.toLocaleString('ko-KR', { month: 'long', day: 'numeric' });

        const weatherInfo = getWeatherInfo(day.sky, day.pty);
        
        const card = document.createElement('div');
        card.className = `forecast-card ${weatherInfo.backgroundClass}-card`; // 카드에도 배경 클래스 적용
        card.innerHTML = `
            <div class="forecast-date">
                <span class="day-of-week">${dayOfWeek}</span>
                <span class="month-day">${monthDay}</span>
            </div>
            <div class="weather-icon-kma">${weatherInfo.icon}</div>
            <div class="weather-description">${weatherInfo.description}</div>
            <div class="temperature">
                <span class="temp-max">최고: ${day.temp_max}°</span>
                <span class="temp-min">최저: ${day.temp_min}°</span>
            </div>
        `;
        forecastContainer.appendChild(card);
    });

    overlay.appendChild(modalContent);
    document.body.appendChild(overlay);
    
    const close = () => {
        modalContent.classList.remove('active');
        overlay.classList.remove('active');
        setTimeout(() => overlay.remove(), 300);
    };

    overlay.addEventListener('click', e => { if (e.target === overlay) close(); });
    modalContent.querySelector('.close-button').addEventListener('click', close);
    
    setTimeout(() => {
        overlay.classList.add('active');
        modalContent.classList.add('active');
    }, 10);
}
function dfs_xy_conv(code, v1, v2) {
    var DEGRAD = Math.PI / 180.0;
    var GRID = 5.0;
    var RE = 6371.00877; 
    var SLAT1 = 30.0;
    var SLAT2 = 60.0;
    var OLON = 126.0;
    var OLAT = 38.0;
    var XO = 43;
    var YO = 136;

    var re = RE / GRID;
    var slat1 = SLAT1 * DEGRAD;
    var slat2 = SLAT2 * DEGRAD;
    var olon = OLON * DEGRAD;
    var olat = OLAT * DEGRAD;

    var sn = Math.tan(Math.PI * 0.25 + slat2 * 0.5) / Math.tan(Math.PI * 0.25 + slat1 * 0.5);
    sn = Math.log(Math.cos(slat1) / Math.cos(slat2)) / Math.log(sn);
    var sf = Math.tan(Math.PI * 0.25 + slat1 * 0.5);
    sf = Math.pow(sf, sn) * Math.cos(slat1) / sn;
    var ro = Math.tan(Math.PI * 0.25 + olat * 0.5);
    ro = re * sf / Math.pow(ro, sn);
    var rs = {};
    if (code == "toXY") {
        rs['lat'] = v1;
        rs['lng'] = v2;
        var ra = Math.tan(Math.PI * 0.25 + (v1) * DEGRAD * 0.5);
        ra = re * sf / Math.pow(ra, sn);
        var theta = v2 * DEGRAD - olon;
        if (theta > Math.PI) theta -= 2.0 * Math.PI;
        if (theta < -Math.PI) theta += 2.0 * Math.PI;
        theta *= sn;
        rs['x'] = Math.floor(ra * Math.sin(theta) + XO + 0.5);
        rs['y'] = Math.floor(ro - ra * Math.cos(theta) + YO + 0.5);
    }
    return rs;
}
        // 신청 취소 실행
        async function cancelApplication(docId, application) {
            const deleted = await deleteFromFirestore(docId, application);
            if (deleted) {
                const dateParts = application.actualDate.split('-');
                const date = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
                const dateString = `${date.getFullYear()}/${date.getMonth() + 1}/${date.getDate()}`;
                alert(`${application.day}(${dateString}) ${application.zone} 신청이 취소되었습니다.`);
                closeCancelModal();
            }
        }
        // 현재 수정 중인 구역 ID 저장
let currentlyEditingZoneId = null;

// 구역 수정 모달 열기
async function editZone(zoneId) {
    currentlyEditingZoneId = zoneId;
    
    // 기존 구역 데이터 불러오기
    const { doc, getDoc } = window.firestoreFunctions;
    const zoneRef = doc(window.db, 'zones', zoneId);
    const zoneSnap = await getDoc(zoneRef);
    
    if (!zoneSnap.exists()) {
        alert('구역 데이터를 불러오는데 실패했습니다. 페이지를 새로고침 해도 동일 문제가 반복되면 관리자에게 문의해주시기 바랍니다.');
        return;
    }
    
    const zoneData = zoneSnap.data();
    
    // 모달에 데이터 채우기
    document.getElementById('editZoneName').value = zoneData.name;
    
    // 스케줄 데이터 채우기
    const container = document.getElementById('editSchedulesContainer');
    container.innerHTML = '';
    
    if (zoneData.schedules && zoneData.schedules.length > 0) {
        zoneData.schedules.forEach((schedule, index) => {
            addScheduleToEditContainer(container, schedule, index);
        });
    } else {
        addNewScheduleToEdit();
    }
    
    // 모달 열기
    document.getElementById('editZoneModal').style.display = 'block';
}

// 수정 모달에 스케줄 추가
function addScheduleToEditContainer(container, schedule, index) {
    const scheduleId = Date.now() + index;
    const scheduleDiv = document.createElement('div');
    scheduleDiv.className = 'schedule-item';
    scheduleDiv.id = `edit-schedule-${scheduleId}`;
    
    scheduleDiv.innerHTML = `
        <div class="schedule-header">
            <div class="schedule-title">일정 #${index + 1}</div>
            <button type="button" class="remove-schedule" onclick="removeEditSchedule(${scheduleId})">삭제</button>
        </div>
        
        <div class="form-group">
            <label>요일 선택</label>
            <div class="day-selection-grid">
                ${['월요일', '화요일', '수요일', '목요일', '금요일', '토요일', '일요일'].map(day => `
                    <div class="day-checkbox">
                        <input type="checkbox" id="edit-${day}-${scheduleId}" value="${day}" ${schedule.days.includes(day) ? 'checked' : ''}>
                        <label for="edit-${day}-${scheduleId}">${day}</label>
                    </div>
                `).join('')}
            </div>
        </div>
        
        <div class="form-group">
            <label>시간대 설정</label>
            <div class="time-slot-settings" id="edit-timeSlots-${scheduleId}">
                ${schedule.timeSlots.map((slot, slotIndex) => `
                    <div class="time-slot-item">
                        <div class="time-slot-row">
                            <div class="time-input-group">
                                <label class="time-input-label">시작 시간</label>
                                <div class="time-picker-container">
                                    <div class="time-picker">
                                        <select class="time-select start-hour">
                                            ${generateHourOptions(slot.time.split('-')[0].split(':')[0])}
                                        </select>
                                        <span>:</span>
                                        <select class="time-select start-minute">
                                            ${generateMinuteOptions(slot.time.split('-')[0].split(':')[1])}
                                        </select>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="time-input-group">
                                <label class="time-input-label">종료 시간</label>
                                <div class="time-picker-container">
                                    <div class="time-picker">
                                        <select class="time-select end-hour">
                                            ${generateHourOptions(slot.time.split('-')[1].split(':')[0])}
                                        </select>
                                        <span>:</span>
                                        <select class="time-select end-minute">
                                            ${generateMinuteOptions(slot.time.split('-')[1].split(':')[1])}
                                        </select>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="time-input-group">
                                <label class="time-input-label">최대 인원</label>
                                <input type="number" class="capacity-input" value="${slot.maxCapacity}" min="1" max="20">
                            </div>
                            
                            <div class="time-input-group">
                                <button type="button" class="btn remove-time" onclick="this.parentElement.parentElement.parentElement.remove()">삭제</button>
                            </div>
                        </div>
                    </div>
                `).join('')}
            </div>
            <div class="time-slot-controls">
                <button type="button" class="btn secondary small" onclick="addTimeSlotToEditSchedule(${scheduleId})">시간대 추가</button>
            </div>
        </div>
    `;
    
    container.appendChild(scheduleDiv);
}

// 수정 모달에 새 스케줄 추가
function addNewScheduleToEdit() {
    const container = document.getElementById('editSchedulesContainer');
    const scheduleId = Date.now();
    
    const scheduleDiv = document.createElement('div');
    scheduleDiv.className = 'schedule-item';
    scheduleDiv.id = `edit-schedule-${scheduleId}`;
    
    scheduleDiv.innerHTML = `
        <div class="schedule-header">
            <div class="schedule-title">일정 #${container.children.length + 1}</div>
            <button type="button" class="remove-schedule" onclick="removeEditSchedule(${scheduleId})">삭제</button>
        </div>
        
        <div class="form-group">
            <label>요일 선택</label>
            <div class="day-selection-grid">
                ${['월요일', '화요일', '수요일', '목요일', '금요일', '토요일', '일요일'].map(day => `
                    <div class="day-checkbox">
                        <input type="checkbox" id="edit-${day}-${scheduleId}" value="${day}">
                        <label for="edit-${day}-${scheduleId}">${day}</label>
                    </div>
                `).join('')}
            </div>
        </div>
        
        <div class="form-group">
            <label>시간대 설정</label>
            <div class="time-slot-settings" id="edit-timeSlots-${scheduleId}">
                <div class="empty-time-slots">시간대를 추가해주세요</div>
            </div>
            <div class="time-slot-controls">
                <button type="button" class="btn secondary small" onclick="addTimeSlotToEditSchedule(${scheduleId})">시간대 추가</button>
            </div>
        </div>
    `;
    
    container.appendChild(scheduleDiv);
}

// 수정 모달에서 시간대 추가
function addTimeSlotToEditSchedule(scheduleId) {
    const container = document.getElementById(`edit-timeSlots-${scheduleId}`);
    
    if (container.querySelector('.empty-time-slots')) {
        container.innerHTML = '';
    }
    
    const timeSlotDiv = document.createElement('div');
    timeSlotDiv.className = 'time-slot-item';
    
    timeSlotDiv.innerHTML = `
        <div class="time-slot-row">
            <div class="time-input-group">
                <label class="time-input-label">시작 시간</label>
                <div class="time-picker-container">
                    <div class="time-picker">
                        <select class="time-select start-hour">
                            ${generateHourOptions('09')}
                        </select>
                        <span>:</span>
                        <select class="time-select start-minute">
                            ${generateMinuteOptions('00')}
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="time-input-group">
                <label class="time-input-label">종료 시간</label>
                <div class="time-picker-container">
                    <div class="time-picker">
                        <select class="time-select end-hour">
                            ${generateHourOptions('12')}
                        </select>
                        <span>:</span>
                        <select class="time-select end-minute">
                            ${generateMinuteOptions('00')}
                        </select>
                    </div>
                </div>
            </div>
            
            <div class="time-input-group">
                <label class="time-input-label">최대 인원</label>
                <input type="number" class="capacity-input" value="4" min="1" max="20">
            </div>
            
            <div class="time-input-group">
                <button type="button" class="btn remove-time" onclick="this.parentElement.parentElement.parentElement.remove()">삭제</button>
            </div>
        </div>
    `;
    
    container.appendChild(timeSlotDiv);
}

// 수정 모달에서 스케줄 삭제
function removeEditSchedule(scheduleId) {
    const scheduleDiv = document.getElementById(`edit-schedule-${scheduleId}`);
    if (scheduleDiv && confirm('이 일정을 삭제하시겠습니까?')) {
        scheduleDiv.remove();
    }
}

// 구역 수정 저장
async function updateZone() {
    const name = document.getElementById('editZoneName').value.trim();
    
    if (!name) {
        alert('구역 이름을 입력해주세요.');
        return;
    }
    
    // 모든 스케줄 데이터 수집
    const schedules = [];
    const scheduleElements = document.querySelectorAll('#editSchedulesContainer .schedule-item');
    
    for (const scheduleElement of scheduleElements) {
        const selectedDays = [];
        const dayCheckboxes = scheduleElement.querySelectorAll('input[type="checkbox"]:checked');
        dayCheckboxes.forEach(checkbox => {
            selectedDays.push(checkbox.value);
        });
        
        if (selectedDays.length === 0) continue;
        
        const timeSlots = [];
        const timeSlotElements = scheduleElement.querySelectorAll('.time-slot-item');
        
        for (const timeSlotElement of timeSlotElements) {
            const startHour = timeSlotElement.querySelector('.start-hour').value;
            const startMinute = timeSlotElement.querySelector('.start-minute').value;
            const endHour = timeSlotElement.querySelector('.end-hour').value;
            const endMinute = timeSlotElement.querySelector('.end-minute').value;
            const capacity = parseInt(timeSlotElement.querySelector('.capacity-input').value);
            
            const timeText = `${startHour}:${startMinute}-${endHour}:${endMinute}`;
            
            timeSlots.push({
                time: timeText,
                maxCapacity: capacity,
                isActive: true
            });
        }
        
        if (timeSlots.length > 0) {
            schedules.push({
                days: selectedDays,
                timeSlots: timeSlots
            });
        }
    }
    
    if (schedules.length === 0) {
        alert('최소 하나의 유효한 일정을 설정해주세요.');
        return;
    }
    
    try {
        const { doc, updateDoc } = window.firestoreFunctions;
        const zoneRef = doc(window.db, 'zones', currentlyEditingZoneId);
        
        await updateDoc(zoneRef, {
            name: name,
            schedules: schedules
        });
        
        alert(`${name} 구역이 수정되었습니다.`);
        closeEditZoneModal();
        loadZonesFromFirestore();
        loadAndDisplayZones();
    } catch (error) {
        console.error('구역 수정 오류:', error);
        alert('구역 수정 중 오류가 발생했습니다.');
    }
}

// 구역 수정 모달 닫기
function closeEditZoneModal() {
    document.getElementById('editZoneModal').style.display = 'none';
    currentlyEditingZoneId = null;
}

        // 모달에서 구역 표시 업데이트
        function updateZoneDisplayForModal() {
            document.querySelectorAll('.zone-label').forEach(label => {
                label.style.background = '';
                label.style.color = '';
                label.style.borderColor = '';
                label.style.cursor = 'pointer';
                label.previousElementSibling.disabled = false;
            });
            console.log('Zone display reset for modal');
        }

        // 특정 요일의 구역 표시 업데이트
function updateZoneDisplay(selectedDay) {
    const zoneLabels = document.querySelectorAll('#zoneSelection .zone-label');
    zoneLabels.forEach(label => {
        const zoneName = label.dataset.zone;
        const zoneObj = zones.find(z => z.name === zoneName);
        
        // 총 용량 계산
        let maxCapacity = 0;
        if (zoneObj && zoneObj.schedules) {
            zoneObj.schedules.forEach(schedule => {
                if (schedule.timeSlots) {
                    schedule.timeSlots.forEach(slot => {
                        if (slot.isActive !== false) {
                            maxCapacity += slot.maxCapacity || 4;
                        }
                    });
                }
            });
        }
        
        const currentCount = getCurrentZoneTotal(zoneName);
        const capacityInfo = label.querySelector('.capacity-info');
        const radioInput = label.previousElementSibling;

        if (capacityInfo) {
            capacityInfo.textContent = `${currentCount}/${maxCapacity}`;
        }

        if (currentCount >= maxCapacity) {
            label.style.background = '#ff6b6b';
            label.style.color = 'white';
            label.style.borderColor = '#ff6b6b';
            label.style.cursor = 'not-allowed';
            if (radioInput) radioInput.disabled = true;
        } else {
            if (!radioInput?.checked) {
                label.style.background = '';
                label.style.color = '';
                label.style.borderColor = '';
            }
            label.style.cursor = 'pointer';
            if (radioInput) radioInput.disabled = false;
        }
    });
    console.log('Zone display updated for day:', selectedDay);
}
        function generateHourOptions(selectedValue = null) {
    let options = '';
    for (let i = 6; i <= 22; i++) {
        const hour = i.toString().padStart(2, '0');
        const isSelected = selectedValue === hour ? 'selected' : '';
        options += `<option value="${hour}" ${isSelected}>${hour}</option>`;
    }
    return options;
}

function generateMinuteOptions(selectedValue = null) {
    const minutes = ['00', '15', '30', '45'];
    let options = '';
    minutes.forEach(minute => {
        const isSelected = selectedValue === minute ? 'selected' : '';
        options += `<option value="${minute}" ${isSelected}>${minute}</option>`;
    });
    return options;
}



function removeTimeSlot(button) {
    if (confirm('이 시간대를 삭제하시겠습니까?')) {
        button.closest('.time-slot-setting').remove();
    }
}

        // 신청자 목록 업데이트
       // 신청자 목록 업데이트 함수 수정
       // 전체 신청현황 업데이트 (더 이상 사용하지 않음)
function updateDisplay() {
    createDayTabs(); // 요일 탭 생성
}
       // 기존 데이터를 새로운 구조로 업데이트하는 함수
async function updateZoneStructure(docId, zoneName, schedules) {
    try {
        const { doc, updateDoc } = window.firestoreFunctions;
        const zoneRef = doc(window.db, 'zones', docId);
        
        await updateDoc(zoneRef, {
            schedules: schedules
        });
        
        // 기존 timeSlots 필드는 삭제 (선택사항)
        await updateDoc(zoneRef, {
            timeSlots: window.firestoreFunctions.deleteField()
        });
        
        console.log(`Zone ${zoneName} updated to new structure`);
    } catch (error) {
        console.error('구역 구조 업데이트 오류:', error);
    }
}
        // 특정 요일의 날짜 가져오기
function getDateForDay(dayName) {
    const today = new Date();
    const currentDay = today.getDay();
    
    // 월요일을 주의 시작으로 설정
    const monday = new Date(today);
    monday.setDate(today.getDate() - (currentDay === 0 ? 6 : currentDay - 1));
    
    const dayMap = {
        '월요일': 0,
        '화요일': 1,
        '수요일': 2,
        '목요일': 3,
        '금요일': 4,
        '토요일': 5,
        '일요일': 6
    };
    
    const targetDate = new Date(monday);
    targetDate.setDate(monday.getDate() + dayMap[dayName]);
    return `${targetDate.getFullYear()}/${targetDate.getMonth() + 1}/${targetDate.getDate()}`;
}
        // ========== 공지사항 관련 함수들 ==========

// Firestore에서 공지사항 로드
async function loadNoticeFromFirestore() {
    try {
        const { doc, getDoc } = window.firestoreFunctions;
        const noticeRef = doc(window.db, 'notices', 'current');
        const noticeSnap = await getDoc(noticeRef);
        
        if (noticeSnap.exists()) {
            currentNotice = noticeSnap.data();
            console.log('Notice loaded:', currentNotice);
        } else {
            currentNotice = null;
            console.log('No notice found');
        }
        
        updateNoticeButton();
        
        // 중요공지이고 로그인된 사용자라면 모달 표시
        if (currentNotice && currentNotice.isImportant && currentUser && !isAdmin) {
            setTimeout(() => {
                openNoticeViewModal();
            }, 500); // 로그인 완료 후 잠깐 딜레이
        }
    } catch (error) {
        console.error('공지사항 로드 오류:', error);
    }
}

// 공지사항 저장
async function saveNotice() {
    const content = document.getElementById('noticeContent').value.trim();
    const isImportant = document.getElementById('isImportantNotice').checked;
    
    if (!content) {
        alert('공지 내용을 입력해주세요.');
        return;
    }
    
    if (content.length > 3000) {
        alert('공지사항은 3000자 이내로 입력해주세요.');
        return;
    }
    
    try {
        const { doc, setDoc } = window.firestoreFunctions;
        const noticeRef = doc(window.db, 'notices', 'current');
        
        const noticeData = {
            content: content,
            isImportant: isImportant,
            lastUpdated: new Date().toISOString(),
            updatedBy: 'admin',
            isActive: true
        };
        
        await setDoc(noticeRef, noticeData);
        
        currentNotice = noticeData;
        updateNoticeButton();
        
        alert('공지사항이 저장되었습니다.');
        closeNoticeManagementModal();
        
        console.log('Notice saved:', noticeData);
    } catch (error) {
        console.error('공지사항 저장 오류:', error);
        alert('공지사항 저장 중 오류가 발생했습니다.');
    }
}

// 공지사항 삭제
async function deleteNotice() {
    if (!currentNotice) {
        alert('삭제할 공지사항이 없습니다.');
        return;
    }
    
    if (!confirm('공지사항을 삭제하시겠습니까?')) {
        return;
    }
    
    try {
        const { doc, deleteDoc } = window.firestoreFunctions;
        const noticeRef = doc(window.db, 'notices', 'current');
        
        await deleteDoc(noticeRef);
        
        currentNotice = null;
        updateNoticeButton();
        
        alert('공지사항이 삭제되었습니다.');
        closeNoticeManagementModal();
        
        console.log('Notice deleted');
    } catch (error) {
        console.error('공지사항 삭제 오류:', error);
        alert('공지사항 삭제 중 오류가 발생했습니다.');
    }
}

// 공지 관리 모달 열기
function openNoticeManagementModal() {
    document.getElementById('noticeManagementModal').style.display = 'block';
    
    // 현재 공지사항 내용 로드
    if (currentNotice) {
        document.getElementById('noticeContent').value = currentNotice.content;
        document.getElementById('isImportantNotice').checked = currentNotice.isImportant || false;
        originalNoticeContent = currentNotice.content;
    } else {
        document.getElementById('noticeContent').value = '';
        document.getElementById('isImportantNotice').checked = false;
        originalNoticeContent = '';
    }
    
    updateCharCount();
    console.log('Notice management modal opened');
}

// 공지 관리 모달 닫기
function closeNoticeManagementModal() {
    document.getElementById('noticeManagementModal').style.display = 'none';
    document.getElementById('noticeContent').value = '';
    document.getElementById('isImportantNotice').checked = false;
    console.log('Notice management modal closed');
}

// 공지 편집 취소
function cancelNoticeEdit() {
    document.getElementById('noticeContent').value = originalNoticeContent;
    closeNoticeManagementModal();
}

// 공지 확인 모달 열기
function openNoticeViewModal() {
    if (!currentNotice) {
        alert('현재 등록된 공지사항이 없습니다.');
        return;
    }
    
    document.getElementById('noticeViewModal').style.display = 'block';
    
    const titleElement = document.getElementById('noticeViewTitle');
    const contentElement = document.getElementById('noticeViewContent');
    const dateElement = document.getElementById('noticeViewDate');
    
    // 제목 설정 (중요공지 여부에 따라)
    if (currentNotice.isImportant) {
        titleElement.textContent = '📢 중요 공지';
        titleElement.className = 'important';
    } else {
        titleElement.textContent = '📢 공지사항';
        titleElement.className = 'normal';
    }
    
    // 내용 설정
    contentElement.innerHTML = currentNotice.content.replace(/\n/g, '<br>');
    
    // 날짜 설정
    const date = new Date(currentNotice.lastUpdated);
    const dateString = ` ${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')} 등록`;
    dateElement.textContent = dateString;
    
    console.log('Notice view modal opened');
}

// 공지 확인 모달 닫기
function closeNoticeViewModal() {
    document.getElementById('noticeViewModal').style.display = 'none';
    console.log('Notice view modal closed');
}

// 공지 버튼 클릭 처리
function handleNoticeButtonClick() {
    if (currentNotice) {
        openNoticeViewModal();
    } else {
        alert('현재 등록된 공지사항이 없습니다.');
    }
}

// 공지 버튼 상태 업데이트
function updateNoticeButton() {
    const button = document.getElementById('noticeButton');
    const badge = document.getElementById('noticeBadge');
    
    if (currentNotice && currentNotice.isActive) {
        button.className = 'notice-button active';
        badge.style.display = 'block';
    } else {
        button.className = 'notice-button inactive';
        badge.style.display = 'none';
    }
}

// 글자수 카운트 업데이트
function updateCharCount() {
    const content = document.getElementById('noticeContent').value;
    document.getElementById('noticeCharCount').textContent = content.length;
}

// 글자수 카운트 이벤트 리스너 추가
document.addEventListener('DOMContentLoaded', function() {
    const noticeContent = document.getElementById('noticeContent');
    if (noticeContent) {
        noticeContent.addEventListener('input', updateCharCount);
    }
});

        // 요일 선택 시 구역 선택 영역 표시
// 요일 선택 시 구역 선택 영역 표시
document.addEventListener('DOMContentLoaded', function() {
    document.querySelectorAll('input[name="day"]').forEach(radio => {
        radio.addEventListener('change', function () {
            const zoneContainer = document.getElementById('zoneSelectionContainer');
            if (this.checked) {
                zoneContainer.classList.add('show');
                
                // transition이 반영된 후에 스크롤 실행
                setTimeout(() => {
                    zoneContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }, 100); // transition 완료 후 스크롤
                
                updateZoneDisplay(this.value);
                document.querySelectorAll('input[name="zone"]').forEach(zoneRadio => {
                    zoneRadio.checked = false;
                });
                console.log('Day selected:', this.value);
            }
        });
    });
});
        // 구역 선택 시 시간 선택 영역 표시
document.addEventListener('change', function(e) {
    if (e.target.name === 'zone') {
        const selectedDay = document.querySelector('input[name="day"]:checked')?.value;
        const selectedZone = e.target.value;
        
        if (selectedDay && selectedZone) {
            const timeContainer = document.getElementById('timeSelectionContainer');
            timeContainer.classList.add('show');
            updateTimeSelection(selectedDay, selectedZone);
            
            // 기존 시간 선택 초기화
            document.querySelectorAll('input[name="time"]').forEach(timeRadio => {
                timeRadio.checked = false;
            });
            
            console.log('Zone selected:', selectedZone);
            
            timeContainer.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }
    }
        if (e.target.name === 'admin-day') {
        const adminZoneContainer = document.getElementById('adminZoneSelectionContainer');
        adminZoneContainer.style.display = 'block';
    }
    
    // 관리자 구역 선택 (새로 추가)  
    if (e.target.name === 'admin-zone') {
        const selectedDay = document.querySelector('input[name="admin-day"]:checked')?.value;
        const selectedZone = e.target.value;
        if (selectedDay && selectedZone) {
            const adminTimeContainer = document.getElementById('adminTimeSelectionContainer');
            adminTimeContainer.style.display = 'block';
            updateAdminTimeSelection(selectedDay, selectedZone); // 이 함수도 새로 만들어야 함
        }
    }
});


        // 폼 제출 이벤트 처리
        document.getElementById('registrationForm').addEventListener('submit', async function (e) {
            e.preventDefault();
                const selectedDay = document.querySelector('input[name="day"]:checked');
                const selectedZone = document.querySelector('input[name="zone"]:checked');
                const selectedTime = document.querySelector('input[name="time"]:checked');

                if (!selectedDay) {
                    alert('요일을 선택해주세요.');
                    console.log('Form submission failed: No day selected');
                    return;
                }
                if (!selectedZone) {
                    alert('구역을 선택해주세요.');
                    console.log('Form submission failed: No zone selected');
                    return;
                }
                if (!selectedTime) {
                    alert('시간을 선택해주세요.');
                    console.log('Form submission failed: No time selected');
                    return;
                }

            const dayValue = selectedDay.value;
            const zoneValue = selectedZone.value;
            const zoneObj = zones.find(z => z.name === zoneValue);
            const maxCapacity = zoneObj ? zoneObj.maxCapacity : 4;

            if (applicants[dayValue][zoneValue].length >= maxCapacity) {
                alert(`${dayValue} ${zoneValue}은 마감되었습니다.`);
                console.log('Form submission failed: Zone at max capacity');
                return;
            }

                const timeValue = selectedTime.value;

                // 같은 시간대에 중복 신청 체크
// 같은 시간대에 중복 신청 체크 (모든 구역에서)
let isDuplicate = false;
zones.forEach(zone => {
    if (applicants[dayValue][zone.name][timeValue] && 
        applicants[dayValue][zone.name][timeValue].includes(currentUser)) {
        isDuplicate = true;
    }
});

if (isDuplicate) {
    alert(`${dayValue} ${timeValue}에 이미 다른 구역에서 신청하셨습니다.`);
    return;
}
// 중복 시간대 확인 (새로 추가)
let isOverlappingTime = false;
userApplications.forEach(app => {
    if (app.day === dayValue && isOverlapping(timeValue, app.timeSlot)) {
        isOverlappingTime = true;
    }
});

if (isOverlappingTime) {
    alert(`${dayValue}에 이미 겹치는 시간대(${timeValue})에 신청하셨습니다. 다른 시간대를 선택해주세요.`);
    return; // 신청 중단
}

            const saved = await saveToFirestore(currentUser, dayValue, zoneValue, timeValue);
            if (saved) {
                alert(`${dayValue} ${zoneValue} 구역 [${timeValue}] 신청이 완료되었습니다!`);
                closeRegistrationModal();
            }
        });

        // 마감된 구역 클릭 방지
        document.addEventListener('click', function (e) {
            if (e.target.classList.contains('zone-label') && e.target.previousElementSibling.disabled) {
                e.preventDefault();
                const selectedDay = document.querySelector('input[name="day"]:checked') || document.querySelector('input[name="admin-day"]:checked');
                if (selectedDay) {
                    alert(`${selectedDay.value} ${e.target.dataset.zone}은 마감되었습니다.`);
                }
            }
        });

        // 모달 외부 클릭 시 닫기
        window.onclick = function (event) {
            const registrationModal = document.getElementById('registrationModal');
            const cancelModal = document.getElementById('cancelModal');
            const adminModal = document.getElementById('adminModal');
            const userManagementModal = document.getElementById('userManagementModal');
            const zoneManagementModal = document.getElementById('zoneManagementModal');
            const statsModal = document.getElementById('statsModal');
            const noticeManagementModal = document.getElementById('noticeManagementModal');
            const noticeViewModal = document.getElementById('noticeViewModal');
            const editZoneModal = document.getElementById('editZoneModal');
                if (event.target === editZoneModal) {
                    closeEditZoneModal();
                }

            if (event.target === registrationModal) {
                closeRegistrationModal();
            }
            if (event.target === cancelModal) {
                closeCancelModal();
            }
            if (event.target === adminModal) {
                closeAdminModal();
            }
            if (event.target === userManagementModal) {
                closeUserManagementModal();
            }
            if (event.target === zoneManagementModal) {
                closeZoneManagementModal();
            }
            if (event.target === statsModal) {
                closeStatsModal();
            }
            if (event.target === noticeManagementModal) {
                closeNoticeManagementModal();
            }
            if (event.target === noticeViewModal) {
                closeNoticeViewModal();
            }
        };

        // 관리자 모달 닫기
        function closeAdminModal() {
            document.getElementById('adminModal').style.display = 'none';
        }

        // 관리자 액션 실행
// 약 1460번째 줄의 함수를 다음과 같이 수정
async function executeAdminAction() {
    const selectedUser = document.getElementById('adminUserSelect').value;
    const selectedAction = document.getElementById('adminAction').value;
    const selectedDay = document.querySelector('input[name="admin-day"]:checked')?.value;
    const selectedZone = document.querySelector('input[name="admin-zone"]:checked')?.value;
    const selectedTime = document.querySelector('input[name="admin-time"]:checked')?.value;
    
    if (!selectedUser || !selectedAction) {
        alert('사용자와 작업을 선택해주세요.');
        return;
    }
    
    if (selectedAction === 'assign') {
        if (!selectedDay || !selectedZone || !selectedTime) {
            alert('요일, 구역, 시간을 모두 선택해주세요.');
            return;
        }
        
        const saved = await saveToFirestore(selectedUser, selectedDay, selectedZone, selectedTime);
        if (saved) {
            alert(`${selectedUser}님이 ${selectedDay} ${selectedZone} ${selectedTime}에 배정되었습니다.`);
            resetAdminForm();
        }
    } else if (selectedAction === 'cancel') {
        // 취소 로직은 별도 UI 필요
        showAdminCancelOptions(selectedUser);
    }
}

        // 관리자 폼 초기화
        function resetAdminForm() {
            alert('폼 초기화 (구현 필요)');
        }</script>

        <!-- 플로팅 메뉴를 body 태그 끝나기 전에 추가 -->
<div class="floating-menu-container" id="floatingMenu">
        <button class="sub-menu-btn weather-btn" onclick="openWeather()" title="날씨 정보">
        🔅
    </button>
        <!-- 글자 크기 조정 버튼 -->
        <div class="sub-menu-btn font-size-btn" onclick="toggleFontSizeSlider()" title="글자 크기 조정">
        Aa
    </div>
        <!-- 새로고침 버튼 -->
    <button class="sub-menu-btn refresh-btn" onclick="refreshPage()" title="페이지 새로고침">
        X
    </button>
   
    <!-- 구역카드 버튼 -->
    <button class="sub-menu-btn home-btn" onclick="goToHome()" title="홈으로 이동">
        🏠
    </button>
    
    <!-- 메인 메뉴 버튼 -->
    <button class="floating-menu-btn" onclick="toggleFloatingMenu()" title="메뉴">
        <div class="hamburger-icon">
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
            <div class="hamburger-line"></div>
        </div>
    </button>
        <!-- 글자 크기 슬라이더 (처음에는 숨김) -->
    <div class="font-size-slider-container" id="fontSizeSlider">
        <div class="slider-header">
            <span>글자 크기</span>
            <button class="close-slider" onclick="closeFontSizeSlider()">×</button>
        </div>
        <input type="range" id="fontSizeRange" min="12" max="24" value="16" step="1">
        <div class="slider-value" id="fontSizeValue">16px</div>
    </div>
</div>

<script>
// 플로팅 메뉴 토글 함수
function toggleFloatingMenu() {
    const menu = document.getElementById('floatingMenu');
    menu.classList.toggle('open');
}
// 새로고침 함수 추가
function refreshPage() {
    window.location.reload();
}

// 홈으로 이동 함수
function goToHome() {
    window.open('https://bgs.jwcard.co.kr', '_blank');
}

// 페이지 로드 시 다크모드 상태 복원
document.addEventListener('DOMContentLoaded', function() {
});

// 메뉴 외부 클릭 시 닫기
document.addEventListener('click', function(event) {
    const menu = document.getElementById('floatingMenu');
    const isClickInsideMenu = menu.contains(event.target);
    
    if (!isClickInsideMenu && menu.classList.contains('open')) {
        menu.classList.remove('open');
    }
});

// ESC 키로 메뉴 닫기
document.addEventListener('keydown', function(event) {
    if (event.key === 'Escape') {
        const menu = document.getElementById('floatingMenu');
        if (menu.classList.contains('open')) {
            menu.classList.remove('open');
        }
    }
});
</script>
</body>
</html>
